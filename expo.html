<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Trader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on mobile while dragging */
        }
        .emoji {
            position: absolute;
            font-size: 2.5rem; /* 40px */
            cursor: grab;
            user-select: none;
            text-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.1s ease-out;
        }
        .emoji.dragging {
            cursor: grabbing;
            transform: scale(1.2);
            z-index: 1000;
        }
        .drop-zone {
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .drop-zone.over {
            transform: scale(1.05);
        }
        #keep-zone.over {
            background-color: #3b82f6; /* blue-500 */
        }
        #sell-zone.over {
             background-color: #22c55e; /* green-500 */
        }
        #keep-zone.danger-over, #sell-zone.danger-over {
            background-color: #ef4444; /* red-500 */
        }

        /* Score animation */
        .score-popup {
            position: absolute;
            animation: floatUp 1.5s ease-out forwards;
            font-weight: bold;
            font-size: 1.25rem;
            pointer-events: none;
            z-index: 2000; /* Ensure it's on top */
        }

        @keyframes floatUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-60px);
            }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100">

    <div id="game-container" class="w-full h-full bg-white dark:bg-gray-800 shadow-2xl relative flex flex-col">

        <!-- Top UI Bar -->
        <div class="flex-shrink-0 flex justify-between items-center p-4 bg-gray-50 dark:bg-gray-700/50 border-b border-gray-200 dark:border-gray-700 z-10">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800 dark:text-white">Emoji Trader</h1>
            <div class="flex space-x-4 md:space-x-6 text-center">
                <div>
                    <span class="text-sm font-semibold text-gray-500 dark:text-gray-400">Score</span>
                    <p id="score" class="text-lg md:text-2xl font-bold text-blue-600 dark:text-blue-400">0</p>
                </div>
                <div>
                    <span class="text-sm font-semibold text-gray-500 dark:text-gray-400">Emojis</span>
                    <p id="emoji-counter" class="text-lg md:text-2xl font-bold text-gray-700 dark:text-gray-300">0 / 100</p>
                </div>
            </div>
        </div>

        <!-- Play Area, contains the emoji field and the drop zones -->
        <div id="play-area" class="flex-grow flex flex-col relative">
            <!-- Emoji Field: where emojis drift -->
            <div id="emoji-field" class="flex-grow relative">
                <!-- Emojis will be dynamically added here -->
            </div>
            
            <!-- Drop Zones -->
            <div class="grid grid-cols-2 gap-0">
                <div id="keep-zone" class="drop-zone bg-blue-400 dark:bg-blue-600 text-white text-center py-6">
                    <h2 class="text-2xl font-bold">KEEP</h2>
                    <p class="text-sm opacity-80">Drag practical items here</p>
                </div>
                <div id="sell-zone" class="drop-zone bg-green-400 dark:bg-green-500 text-white text-center py-6">
                    <h2 class="text-2xl font-bold">SELL</h2>
                    <p class="text-sm opacity-80">Drag valuable items here</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-20">
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-8 text-center max-w-sm w-full">
            <h2 class="text-3xl font-bold mb-2 text-gray-800 dark:text-white">Game Over!</h2>
            <p class="text-gray-600 dark:text-gray-300 mb-4">You finished with a final score of:</p>
            <p id="final-score" class="text-5xl font-bold text-blue-600 dark:text-blue-400 mb-6">0</p>
            <button id="restart-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg w-full text-lg transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>


    <script>
        // --- Element References ---
        const playArea = document.getElementById('play-area');
        const emojiField = document.getElementById('emoji-field');
        const scoreEl = document.getElementById('score');
        const emojiCounterEl = document.getElementById('emoji-counter');
        const keepZoneEl = document.getElementById('keep-zone');
        const sellZoneEl = document.getElementById('sell-zone');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreEl = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // --- Game Configuration ---
        const MAX_EMOJIS = 100;
        const EMOJI_SPAWN_INTERVAL = 800; // ms, faster spawning

        const EMOJI_CATEGORIES = {
            practical: ['ðŸ”¨','ðŸ”§','ðŸª“','â›ï¸','ðŸ”©','âš™ï¸','ðŸ§±','ðŸ‘•','ðŸ‘–','ðŸ§¦','ðŸ‘Ÿ','ðŸ¥¾','ðŸ§¤','ðŸ‘“','ðŸŽ','ðŸž','ðŸ¥•','ðŸŒ½','ðŸ¥›','â˜•','ðŸ’§','ðŸª‘','ðŸ›‹ï¸','ðŸ›ï¸','ðŸšª','ðŸ’¡','ðŸ’»','ðŸ“±','âŒš','ðŸš—','ðŸš²','ðŸšš','ðŸ“¦','ðŸ“Ž','âœ‚ï¸','ðŸ“','ðŸ“š','ðŸ“–','ðŸ§¼','ðŸ§½','ðŸª£','ðŸ”‘','ðŸ—ºï¸','ðŸ§­','ðŸ”‹'],
            valuable: ['ðŸ’Ž','ðŸ’°','ðŸ‘‘','ðŸ’','ðŸ†','ðŸ¥‡','ðŸ–¼ï¸','ðŸº','ðŸ—¿','ðŸ°','ðŸ¯','ðŸ›ï¸','ðŸ“ˆ','ðŸš€','ðŸš','ðŸ›¥ï¸','ðŸŽï¸','ðŸŽ»','ðŸŽ·','ðŸŽº','ðŸŽ¹','ðŸŽ¨','ðŸŽ¬','ðŸŽ©','âœ¨','ðŸŒŸ','ðŸ’«','ðŸŒ','ðŸ‡','ðŸ£','ðŸ±','ðŸ·','ðŸ¥‚','ðŸŽ','ðŸŽ‰','ðŸŽŠ','ðŸ§§','ðŸ“œ','ðŸ–‹ï¸','ðŸ”­','ðŸ”¬','ðŸ§¬','ðŸ¤–','ðŸ‘¾','âšœï¸'],
            dangerous: ['ðŸ’£','ðŸ§¨','ðŸ”«','ðŸ”ª','â˜ ï¸','â˜£ï¸','â˜¢ï¸','ðŸ¦‚','ðŸ','ðŸ”¥']
        };

        // --- Game State ---
        let score = 0;
        let resolvedEmojiCount = 0;
        let activeEmojis = [];
        let shuffledEmojis = [];
        let emojiSpawner;
        let animationFrameId;

        // --- Dragging State ---
        let draggedEmoji = null;
        let offsetX = 0;
        let offsetY = 0;

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function startGame() {
            // Reset state
            score = 0;
            resolvedEmojiCount = 0;
            activeEmojis = [];
            emojiField.innerHTML = '';
            updateUI();
            gameOverModal.classList.add('hidden');

            // Prepare the emojis for the new game
            const practicalItems = EMOJI_CATEGORIES.practical.map(char => ({ char, type: 'practical', value: 10 }));
            const valuableItems = EMOJI_CATEGORIES.valuable.map(char => ({ char, type: 'valuable', value: 25 }));
            const dangerousItems = EMOJI_CATEGORIES.dangerous.map(char => ({ char, type: 'dangerous', value: -50 }));
            let allEmojis = [...practicalItems, ...valuableItems, ...dangerousItems];
            shuffledEmojis = shuffleArray(allEmojis);

            // Clear any lingering intervals or animation frames
            if (emojiSpawner) clearInterval(emojiSpawner);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            // Start spawning emojis from the shuffled list
            emojiSpawner = setInterval(spawnEmoji, EMOJI_SPAWN_INTERVAL);
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function spawnEmoji() {
            if (shuffledEmojis.length === 0) {
                clearInterval(emojiSpawner);
                return;
            }

            const emojiData = shuffledEmojis.pop();
            
            const emojiFieldRect = emojiField.getBoundingClientRect();
            if (emojiFieldRect.width === 0 || emojiFieldRect.height === 0) return;
            
            const x = emojiFieldRect.width / 2;
            const y = emojiFieldRect.height / 2;

            const emojiEl = document.createElement('div');
            emojiEl.classList.add('emoji');
            emojiEl.textContent = emojiData.char;

            const emojiState = {
                el: emojiEl,
                data: emojiData,
                x: x,
                y: y,
                dx: (Math.random() - 0.5) * 2.5, // Slightly faster drift
                dy: (Math.random() - 0.5) * 2.5
            };
            
            emojiEl.style.left = `${x}px`;
            emojiEl.style.top = `${y}px`;

            activeEmojis.push(emojiState);
            emojiField.appendChild(emojiEl);
            
            emojiEl.addEventListener('mousedown', startDrag);
            emojiEl.addEventListener('touchstart', startDrag, { passive: false });
        }
        
        function gameLoop() {
            // End condition: all 100 emojis resolved
            if (resolvedEmojiCount >= MAX_EMOJIS && activeEmojis.length === 0) {
                 endGame();
                 return;
            }

            const emojiFieldRect = emojiField.getBoundingClientRect();

            for (let i = activeEmojis.length - 1; i >= 0; i--) {
                const emoji = activeEmojis[i];
                if (emoji.el.classList.contains('dragging')) continue;

                emoji.x += emoji.dx;
                emoji.y += emoji.dy;
                emoji.el.style.left = `${emoji.x}px`;
                emoji.el.style.top = `${emoji.y}px`;

                if (emoji.x < 0 || emoji.x > emojiFieldRect.width - emoji.el.offsetWidth ||
                    emoji.y < 0 || emoji.y > emojiFieldRect.height - emoji.el.offsetHeight) {
                    emoji.el.remove();
                    activeEmojis.splice(i, 1);
                    incrementResolvedCounter();
                }
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            scoreEl.textContent = score;
            emojiCounterEl.textContent = `${Math.min(resolvedEmojiCount, MAX_EMOJIS)} / ${MAX_EMOJIS}`;
        }

        function incrementResolvedCounter() {
            resolvedEmojiCount++;
            updateUI();
        }
        
        function addScore(points, x, y) {
            score += points;
            updateUI();

            const popup = document.createElement('div');
            popup.textContent = (points > 0 ? `+` : '') + points;
            popup.className = `score-popup ${points > 0 ? 'text-green-500' : 'text-red-500'}`;
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            playArea.appendChild(popup);
            setTimeout(() => popup.remove(), 1500);
        }

        function endGame() {
            clearInterval(emojiSpawner);
            cancelAnimationFrame(animationFrameId);
            finalScoreEl.textContent = score;
            gameOverModal.style.display = 'flex';
        }

        // --- Drag and Drop Logic ---

        function startDrag(e) {
            e.preventDefault();
            draggedEmoji = activeEmojis.find(emoji => emoji.el === e.target);
            if (!draggedEmoji) return;
            
            draggedEmoji.el.classList.add('dragging');
            const event = e.touches ? e.touches[0] : e;
            const rect = e.target.getBoundingClientRect();
            offsetX = event.clientX - rect.left;
            offsetY = event.clientY - rect.top;

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        }

        function onDrag(e) {
            if (!draggedEmoji) return;
            e.preventDefault();

            const event = e.touches ? e.touches[0] : e;
            const playAreaRect = playArea.getBoundingClientRect();
            let newX = event.clientX - playAreaRect.left - offsetX;
            let newY = event.clientY - playAreaRect.top - offsetY;

            newX = Math.max(0, Math.min(newX, playAreaRect.width - draggedEmoji.el.offsetWidth));
            newY = Math.max(0, Math.min(newY, playAreaRect.height - draggedEmoji.el.offsetHeight));
            
            draggedEmoji.el.style.left = `${newX}px`;
            draggedEmoji.el.style.top = `${newY}px`;
            
            checkDropZoneHover(event.clientX, event.clientY);
        }
        
        function checkDropZoneHover(clientX, clientY) {
            const keepRect = keepZoneEl.getBoundingClientRect();
            const sellRect = sellZoneEl.getBoundingClientRect();
            const isDangerous = draggedEmoji && draggedEmoji.data.type === 'dangerous';

            const overKeep = clientX > keepRect.left && clientX < keepRect.right && clientY > keepRect.top && clientY < keepRect.bottom;
            const overSell = clientX > sellRect.left && clientX < sellRect.right && clientY > sellRect.top && clientY < sellRect.bottom;

            keepZoneEl.classList.toggle('over', overKeep && !isDangerous);
            sellZoneEl.classList.toggle('over', overSell && !isDangerous);

            keepZoneEl.classList.toggle('danger-over', overKeep && isDangerous);
            sellZoneEl.classList.toggle('danger-over', overSell && isDangerous);
        }

        function endDrag(e) {
            if (!draggedEmoji) return;
            
            const event = e.changedTouches ? e.changedTouches[0] : e;
            handleDrop(event.clientX, event.clientY);

            draggedEmoji.el.classList.remove('dragging');
            draggedEmoji = null;

            keepZoneEl.classList.remove('over', 'danger-over');
            sellZoneEl.classList.remove('over', 'danger-over');

            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchend', endDrag);
        }
        
        function handleDrop(clientX, clientY) {
            const keepRect = keepZoneEl.getBoundingClientRect();
            const sellRect = sellZoneEl.getBoundingClientRect();
            const emojiData = draggedEmoji.data;
            let points = 0;
            
            const droppedInKeep = clientX > keepRect.left && clientX < keepRect.right && clientY > keepRect.top && clientY < keepRect.bottom;
            const droppedInSell = clientX > sellRect.left && clientX < sellRect.right && clientY > sellRect.top && clientY < sellRect.bottom;

            if (droppedInKeep || droppedInSell) {
                if (emojiData.type === 'dangerous') {
                    points = emojiData.value; // Heavy penalty
                } else if (droppedInKeep) {
                    points = (emojiData.type === 'practical') ? emojiData.value : -Math.round(emojiData.value / 2);
                } else if (droppedInSell) {
                    points = (emojiData.type === 'valuable') ? emojiData.value : -Math.round(emojiData.value / 2);
                }
                
                addScore(points, draggedEmoji.el.offsetLeft, draggedEmoji.el.offsetTop);
                draggedEmoji.el.remove();
                const index = activeEmojis.findIndex(emoji => emoji.el === draggedEmoji.el);
                if (index > -1) activeEmojis.splice(index, 1);
                incrementResolvedCounter();

            } else {
                draggedEmoji.x = draggedEmoji.el.offsetLeft;
                draggedEmoji.y = draggedEmoji.el.offsetTop;
            }
        }

        restartButton.addEventListener('click', startGame);

        window.onload = startGame;
    </script>
</body>
</html>
