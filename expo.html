<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Isometric Grid UI ‚Äî Yellow Tile + Polished UI</title>
  <style>
    :root { --vh: 1vh; }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; margin: 0; background: #000; color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    #app { position: fixed; inset: 0; height: 100svh; height: calc(var(--vh) * 100); display: grid; grid-template-rows: 1fr auto; background:#000; }
    #stage { position: relative; display: grid; place-items: center; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }

    /* Polished control pad */
    .controls {
      display: grid;
      grid-template-areas: ". up ." "left mid right" ". down .";
      grid-template-columns: 72px 72px 72px;
      grid-template-rows: 72px 72px 72px;
      justify-content: center;
      gap: 12px; padding: 14px;
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 14px);
      user-select: none;
    }
    .btn {
      width:72px;height:72px;border-radius:20px;border:1px solid rgba(255,255,255,0.14);
      background: radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.06) 35%, rgba(0,0,0,0.0) 100%), linear-gradient(#141414,#0e0e0e);
      color:#fff;display:grid;place-items:center;font-size:22px;
      box-shadow: 0 8px 20px rgba(0,0,0,.55), inset 0 2px 6px rgba(255,255,255,.05), inset 0 -2px 10px rgba(0,0,0,.6);
      transition: transform .06s ease, background-color .1s ease, border-color .1s ease, box-shadow .12s ease;
      backdrop-filter: blur(2px);
    }
    .btn:active { transform: translateY(1px) scale(.985); border-color: rgba(255,255,255,0.24); box-shadow: 0 6px 14px rgba(0,0,0,.6), inset 0 2px 10px rgba(255,255,255,.07); }
    .btn:focus-visible { outline:2px solid rgba(255,255,255,.35); outline-offset: 2px; }
    .up{grid-area:up}.down{grid-area:down}.left{grid-area:left}.right{grid-area:right}
    .mid{grid-area:mid;opacity:.45;border-style:dashed;border-color:rgba(255,255,255,.2)}
    .legend { text-align:center; font-size:12px; opacity:.8; margin-top:4px; letter-spacing:.2px; }
  </style>
</head>
<body>
  <div id="app" role="application" aria-label="Isometric grid with movable cube and collectibles">
    <div id="stage"><canvas id="game" aria-hidden="true"></canvas></div>
    <div class="controls" aria-label="Controls">
      <button class="btn up"    data-move="0,-1" aria-label="Move up">‚ñ≤</button>
      <button class="btn left"  data-move="-1,0" aria-label="Move left">‚óÑ</button>
      <div class="btn mid" aria-hidden="true">‚ñ†</div>
      <button class="btn right" data-move="1,0" aria-label="Move right">‚ñ∫</button>
      <button class="btn down"  data-move="0,1" aria-label="Move down">‚ñº</button>
      <div class="legend">Current square is yellow ¬∑ Collect the emojis</div>
    </div>
  </div>

  <script>
    // Viewport fix for mobile chrome/safari UI
    function setVH(){ document.documentElement.style.setProperty('--vh', (window.innerHeight*0.01)+'px'); }
    setVH(); addEventListener('resize', setVH); addEventListener('orientationchange', () => setTimeout(setVH, 100));

    // Canvas
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dpr = Math.max(1, Math.min(3, devicePixelRatio || 1));
    function fitCanvas(){ const r = canvas.getBoundingClientRect(); canvas.width = Math.floor(r.width*dpr); canvas.height = Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); draw(); }

    // Grid model
    const grid = { cols: 12, rows: 12, tileW: 64, tileH: 32 };
    const cube = { x: 5, y: 5 };

    // Collectibles
    const EMOJIS = ['‚≠ê','üçÄ','üî•','üíé','üéØ','‚ö°','üß©','üçé'];
    const collectibles = [];
    function seedCollectibles(n=6){
      const used = new Set([key(cube.x, cube.y)]);
      while(collectibles.length < n){
        const x = Math.floor(Math.random()*grid.cols);
        const y = Math.floor(Math.random()*grid.rows);
        const k = key(x,y);
        if(used.has(k)) continue;
        used.add(k);
        const emoji = EMOJIS[Math.floor(Math.random()*EMOJIS.length)];
        collectibles.push({x,y,emoji});
      }
    }
    function key(x,y){ return x+','+y; }

    // Isometric projection
    function iso(x, y){ return { x: (x - y) * (grid.tileW/2), y: (x + y) * (grid.tileH/2) }; }

    // Layout: center terrain, then nudge up a bit so it feels centered in portrait
    function layout(){
      const corners = [ iso(0,0), iso(grid.cols,0), iso(grid.cols,grid.rows), iso(0,grid.rows) ];
      const minX = Math.min(...corners.map(p=>p.x));
      const maxX = Math.max(...corners.map(p=>p.x));
      const minY = Math.min(...corners.map(p=>p.y));
      const maxY = Math.max(...corners.map(p=>p.y));
      const gw = maxX - minX, gh = maxY - minY;
      const r = canvas.getBoundingClientRect();
      const cx = (r.width - gw)/2 - minX;
      const cy = (r.height - gh)/2 - minY - grid.tileH*0.25; // slight upward bias
      return { cx, cy };
    }

    // Draw exact tiles so each diamond = 1 step. The current tile is a solid yellow diamond.
    function drawTiles(){
      const { cx, cy } = layout();
      ctx.save();
      ctx.translate(cx, cy);
      for(let y=0; y<grid.rows; y++){
        for(let x=0; x<grid.cols; x++){
          const p0 = iso(x, y);
          const p1 = iso(x+1, y);
          const p2 = iso(x+1, y+1);
          const p3 = iso(x, y+1);

          // Path for tile
          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.closePath();

          // Fill style: yellow for current tile, subtle checker otherwise
          if (x === cube.x && y === cube.y) {
            ctx.fillStyle = 'rgba(255,215,0,0.6)'; // grid-aligned shadow highlight
            ctx.fill();
            ctx.lineWidth = 1.25; ctx.strokeStyle = 'rgba(255,215,0,0.9)'; ctx.stroke();
          } else {
            ctx.fillStyle = ((x+y)&1) ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.06)';
            ctx.fill();
            ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.stroke();
          }
        }
      }

      // Boundary
      const c = [ iso(0,0), iso(grid.cols,0), iso(grid.cols,grid.rows), iso(0,grid.rows) ];
      ctx.beginPath(); ctx.moveTo(c[0].x, c[0].y); for(let i=1;i<c.length;i++) ctx.lineTo(c[i].x, c[i].y); ctx.closePath();
      ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.stroke();
      ctx.restore();
    }

    // Draw collectibles as emojis centered on tiles
    function drawCollectibles(){
      const { cx, cy } = layout();
      const fontSize = Math.floor((grid.tileH) * 1.2); // scale with tile
      ctx.font = `${fontSize}px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      for(const it of collectibles){
        const p = iso(it.x + 0.5, it.y + 0.5);
        ctx.save();
        ctx.translate(cx + p.x, cy + p.y + grid.tileH*0.15);
        ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 6;
        ctx.fillText(it.emoji, 0, 0);
        ctx.restore();
      }
    }

    function drawCube(){
      const { cx, cy } = layout();
      const center = iso(cube.x + 0.5, cube.y + 0.5);
      const baseX = cx + center.x;
      const baseY = cy + center.y;
      const w = grid.tileW/2, h = grid.tileH/2, height = grid.tileH; // cube height

      // Top
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - height);
      ctx.lineTo(baseX + w, baseY - height + h);
      ctx.lineTo(baseX, baseY - height + 2*h);
      ctx.lineTo(baseX - w, baseY - height + h);
      ctx.closePath(); ctx.fillStyle = '#9ad5ff'; ctx.fill();

      // Right
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - height + 2*h);
      ctx.lineTo(baseX + w, baseY - height + h);
      ctx.lineTo(baseX + w, baseY + h);
      ctx.lineTo(baseX, baseY + 2*h);
      ctx.closePath(); ctx.fillStyle = '#6aa7d6'; ctx.fill();

      // Left
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - height + 2*h);
      ctx.lineTo(baseX - w, baseY - height + h);
      ctx.lineTo(baseX - w, baseY + h);
      ctx.lineTo(baseX, baseY + 2*h);
      ctx.closePath(); ctx.fillStyle = '#4f88b5'; ctx.fill();

      // Base marker for extra grounding
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX + w/1.2, baseY + h/1.2);
      ctx.lineTo(baseX, baseY + 2*h/1.2);
      ctx.lineTo(baseX - w/1.2, baseY + h/1.2);
      ctx.closePath(); ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.stroke();
    }

    function clear(){ ctx.clearRect(0,0,canvas.width,canvas.height); }
    function draw(){ clear(); drawTiles(); drawCollectibles(); drawCube(); }

    function move(dx, dy){
      const nx = Math.max(0, Math.min(grid.cols-1, cube.x + dx));
      const ny = Math.max(0, Math.min(grid.rows-1, cube.y + dy));
      if (nx !== cube.x || ny !== cube.y){
        cube.x = nx; cube.y = ny;
        // Pickup collectibles
        const idx = collectibles.findIndex(it => it.x === cube.x && it.y === cube.y);
        if(idx !== -1){ collectibles.splice(idx,1); }
        // Optional light haptic
        if (navigator.vibrate) navigator.vibrate(10);
        draw();
      }
    }

    // Button press helpers for nicer feel
    function bindButton(btn){
      const [dx, dy] = btn.dataset.move.split(',').map(Number);
      let holdTimer = null, repeatTimer = null;
      const pressOnce = () => move(dx, dy);
      const start = () => {
        pressOnce();
        holdTimer = setTimeout(() => { repeatTimer = setInterval(pressOnce, 120); }, 300);
      };
      const stop = () => { clearTimeout(holdTimer); clearInterval(repeatTimer); holdTimer = repeatTimer = null; };
      btn.addEventListener('mousedown', start);
      btn.addEventListener('touchstart', e => { e.preventDefault(); start(); }, { passive: false });
      addEventListener('mouseup', stop);
      addEventListener('mouseleave', stop);
      addEventListener('touchend', stop);
      addEventListener('touchcancel', stop);
      btn.addEventListener('click', e => e.preventDefault()); // prevent duplicate after touch
    }

    document.querySelectorAll('.btn[data-move]').forEach(bindButton);
    addEventListener('keydown', e => { if(e.key==='ArrowUp')move(0,-1); else if(e.key==='ArrowDown')move(0,1); else if(e.key==='ArrowLeft')move(-1,0); else if(e.key==='ArrowRight')move(1,0); });

    // Init
    seedCollectibles(6);
    const ro = new ResizeObserver(fitCanvas); ro.observe(document.getElementById('stage')); fitCanvas();
  </script>
</body>
</html>
