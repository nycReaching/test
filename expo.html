<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Minimal Game UI</title>
    <style>
      :root {
        --blue: #1e90ff;
        --pink: #ff2ea6;
        --border: 3px;
        /* Slim bar height scales by viewport height but stays usable */
        --bar-h: clamp(4px, 2.5vh, 12px);
        /* Round button size */
        --btn: clamp(44px, 9vh, 72px);
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }

      body {
        margin: 0;
        background: #000; /* black background */
        /* Robust full-viewport sizing on mobile */
        min-height: 100dvh;
        min-height: 100svh;
        min-height: calc(var(--vh, 1vh) * 100);
      }

      /* Safe-area wrapper for notches */
      .wrap {
        position: fixed;
        inset: 0;
        padding-top: env(safe-area-inset-top);
        padding-right: env(safe-area-inset-right);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        overflow: hidden;
      }

      /* Blue border frame */
      .frame {
        position: absolute;
        inset: 0;
        border: var(--border) solid var(--blue);
        pointer-events: none;
        z-index: 10; /* topmost so the border stays visible */
      }

      /* Slim horizontal middle section */
      .mid {
        position: absolute;
        left: var(--border);
        right: var(--border);
        top: 50%;
        height: 0; /* line only */
        transform: translateY(-50%);
        border-top: var(--border) solid var(--blue);
        background: transparent;
        pointer-events: none;
        z-index: 1;
      }

      /* Image regions */
      .slot {
        position: absolute;
        left: var(--border);
        right: var(--border);
        overflow: hidden;
      }
      .slot.top { top: var(--border); bottom: calc(50% + var(--bar-h) / 2); }
      .slot.bottom { bottom: var(--border); top: calc(50% + var(--bar-h) / 2); }

      .slot img {
        position: absolute;
        max-width: 80%;
        max-height: 80%;
        width: auto;
        height: auto;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        object-fit: contain;
        user-select: none;
        -webkit-user-drag: none;
      }


      /* Round tappable button on the mid bar, center-left */
      .btn {
        position: absolute;
        width: var(--btn);
        height: var(--btn);
        border-radius: 50%;
        border: var(--border) solid var(--pink);
        background: var(--pink);
        left: 50%; /* centered */
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 4;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        outline: none;
        cursor: pointer;
        box-shadow: 0 10px 24px rgba(0,0,0,0.35), 0 6px 18px rgba(255,46,166,0.35);
        transition: transform 120ms ease-out, box-shadow 120ms ease-out;
      }
      .btn:active { transform: translate(-50%, -50%) scale(0.94); }

      /* Tap animation class toggled on click */
      @keyframes pulse {
        0% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(0.92); }
        100% { transform: translate(-50%, -50%) scale(1); }
      }
      .btn.pulse { animation: pulse 180ms ease-out; }

      /* Shake + zoom effect for active cycling */
      @keyframes rumbleZoom {
        0%   { transform: translate(0, 0) scale(1.00); }
        20%  { transform: translate(-1.2%, 0.8%) scale(1.03); }
        40%  { transform: translate(1.1%, -0.9%) scale(1.05); }
        60%  { transform: translate(-0.8%, -0.6%) scale(1.04); }
        80%  { transform: translate(0.9%, 1.0%) scale(1.06); }
        100% { transform: translate(0, 0) scale(1.00); }
      }
      .slot.fx {
        animation: rumbleZoom 120ms linear infinite;
        will-change: transform;
      }

      /* Enemy HP bar */
      .hp__track {
        position: absolute;
        top: 10px;
        left: 16px;
        right: 16px;
        height: 12px;
        border-radius: 999px;
        background: #1a1a1a;
        border: 2px solid #ffd400;
        overflow: hidden;
        z-index: 3;
      }
      .hp__fill {
        height: 100%;
        width: 100%;
        background: #ffd400;
        transition: width 3500ms linear;
      }
      .hp__track.flash { animation: hpflash 800ms ease-in-out 3; }
      @keyframes hpflash { 0%,100%{ box-shadow: 0 0 0 rgba(255,0,0,0); } 50%{ box-shadow: 0 0 14px rgba(255,0,0,0.95), inset 0 0 6px rgba(255,0,0,0.85); } }

      /* Rapid red damage numbers */
      .dmg {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        color: #ff3030;
        font: 800 clamp(28px, 6vw, 64px)/1 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
        text-shadow: 0 0 6px rgba(255,0,0,0.85), 0 0 12px rgba(255,0,0,0.55);
        pointer-events: none;
        mix-blend-mode: screen;
        animation: dmgPop 320ms ease-out forwards;
      }
      @keyframes dmgPop {
        0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }
        40%  { opacity: 1; transform: translate(-50%, -65%) scale(1.15); }
        100% { opacity: 0; transform: translate(-50%, -82%) scale(0.95); }
      }

      /* Respect reduced motion */
      @media (prefers-reduced-motion: reduce) {
        .slot.fx { animation: none; }
        .dmg { animation: none; opacity: 1; }
      }

      /* Ensure layout remains clean if shown in landscape */
      @media (orientation: landscape) {
        .mid { --bar-h: clamp(3px, 1.5vh, 10px); }
        .btn { left: 50%; }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="slot top">
        <div class="hp__track" aria-label="Enemy HP"><div class="hp__fill"></div></div>
        <img src="enemy1.jpg" alt="" draggable="false" />
      </div>

      <div class="slot bottom">
        <img src="elf1.jpg" alt="" draggable="false" />
      </div>

      <div class="mid"></div>
      <button class="btn" type="button" aria-label="action"></button>
      <div class="frame"></div>
    </div>

    <script>
      'use strict';

      // Mobile Safari viewport height fix
      (function () {
        const root = document.documentElement;
        function setVH() {
          root.style.setProperty('--vh', window.innerHeight * 0.01 + 'px');
        }
        setVH();
        window.addEventListener('resize', setVH, { passive: true });
        window.addEventListener('orientationchange', setVH, { passive: true });
      })();

      // Utilities
      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Spawn rapid damage numbers over a slot for a duration
      function spawnDamageNumbers(slotEl, durationMs, everyMs) {
        if (!slotEl) return Promise.resolve();
        const start = performance.now();
        return new Promise(function(resolve){
          const timer = setInterval(function(){
            const n = document.createElement('span');
            n.className = 'dmg';
            n.textContent = String(randInt(5, 25));
            // Random placement within the slot area using percentages
            const x = 5 + Math.random() * 90; // avoid edges
            const y = 5 + Math.random() * 90;
            n.style.left = x + '%';
            n.style.top  = y + '%';
            slotEl.appendChild(n);
            // Auto-remove after animation (~320ms)
            setTimeout(function(){ n.remove(); }, 360);
          }, everyMs);

          function stop(){ clearInterval(timer); resolve(); }
          function rafCheck(t){
            if (t - start >= durationMs) stop();
            else requestAnimationFrame(rafCheck);
          }
          requestAnimationFrame(rafCheck);
        });
      }

      // Button tap animation + image cycling sequence
      (function(){
        const btn = document.querySelector('.btn');
        const charImg = document.querySelector('.slot.bottom img');
        const enemyImg = document.querySelector('.slot.top img');
        const hpTrack = document.querySelector('.hp__track');
        const hpFill  = document.querySelector('.hp__fill');

        const charFrames = ['elf1.jpg','elf2.jpg','elf3.jpg'];
        const enemyFrames = ['enemy1.jpg','enemy2.jpg','enemy3.jpg'];

        // Preload to minimize flicker
        [...charFrames, ...enemyFrames].forEach(function(src){ const i = new Image(); i.src = src; });

        let busy = false;

        function cycleImage(el, frames, ms, intervalMs) {
          return new Promise(function(resolve){
            var idx = 0;
            var slot = el.closest('.slot');
            if (slot) slot.classList.add('fx');

            var t0 = performance.now();
            // Set start frame to avoid off-by-one visual pop
            el.src = frames[idx];
            var timer = setInterval(function(){
              idx = (idx + 1) % frames.length;
              el.src = frames[idx];
            }, intervalMs);

            function stop(){
              clearInterval(timer);
              if (slot) slot.classList.remove('fx');
              resolve();
            }
            function rafCheck(t){
              if (t - t0 >= ms) stop();
              else requestAnimationFrame(rafCheck);
            }
            requestAnimationFrame(rafCheck);
          });
        }

                async function runSequence(){
          if (busy) return;
          busy = true;

          // Button pulse animation retrigger
          btn.classList.remove('pulse');
          void btn.offsetWidth; // reflow
          btn.classList.add('pulse');

          const enemySlot = enemyImg ? enemyImg.closest('.slot') : null;

          // Start elf first, total 3.5s
          const elfP = cycleImage(charImg, charFrames, 2500, 80);

          // Stagger enemy start by 0.5s. Enemy runs 3.0s so both end at 3.5s
          await new Promise(r => setTimeout(r, 500));
          // Reset HP bar to full instantly before starting
          if (hpFill) {
            hpFill.style.transition = 'none';
            hpFill.style.width = '100%';
            void hpFill.offsetWidth;
          }

          // Enemy starts; runs 3.5s so it ends 0.5s after elf
          const enemyDuration = 3500;
          const enemyP = cycleImage(enemyImg, enemyFrames, enemyDuration, 80);
          const dmgP = spawnDamageNumbers(enemySlot, enemyDuration, 120);

          // Start HP bar flash + depletion tied to enemy animation
          if (hpTrack && hpFill) {
            hpTrack.classList.add('flash');
            // start depletion
            hpFill.style.transition = `width ${enemyDuration}ms linear`;
            requestAnimationFrame(()=>{ hpFill.style.width = '0%'; });
            // stop flash at end
            setTimeout(()=> hpTrack.classList.remove('flash'), enemyDuration);
          } // larger numbers already styled; slower spawn

          await Promise.all([elfP, enemyP, dmgP]);

          busy = false;
        }

        if (btn) {
          btn.addEventListener('click', runSequence, { passive: true });
        }

        // --- Basic non-visual tests (console only) ---
        (function runTests(){
          // Use tiny data-URL images so tests do not depend on project assets
          var px1 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9p6J2x0AAAAASUVORK5CYII=';
          var px2 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/w8AApEB1wP2y+0AAAAASUVORK5CYII=';
          var px3 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8//8AAoMB4pKxY0QAAAAASUVORK5CYII=';

          var dummy = new Image();
          dummy.src = px1;

          var start = performance.now();
          var p = cycleImage(dummy, [px1, px2, px3], 120, 40);
          console.assert(typeof p === 'object' && typeof p.then === 'function', 'cycleImage returns a Promise');
          p.then(function(){
            var elapsed = performance.now() - start;
            console.assert(elapsed >= 100, 'cycleImage duration should be at least ~100ms');
            console.assert([px1, px2, px3].indexOf(dummy.src) !== -1, 'dummy src should be set to one of the frames');
          }).catch(function(e){
            console.error('Test error:', e);
          });
        })();
        // --- End tests ---
      })();
    </script>
  </body>
</html>
