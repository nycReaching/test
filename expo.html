<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Minimal Game UI</title>
  <style>
    :root{
      --bg: #ffffff;
      --feed-bg: #0c0f14;
      --text-muted: #7f8ea3;
      --accent: #2dd4bf; /* teal */
    }

    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{ margin: 0; background: var(--bg); color: #111; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }

    /* Full-height app with modern viewport units and safe-area support */
    .app{ height: 100vh; display: flex; flex-direction: column; overflow: hidden;
      padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); }
    @supports (height: 100svh){ .app{ height: 100svh; } }
    @supports (height: 100dvh){ .app{ height: 100dvh; } }

    /* Top feed panel ~25% */
    .feed{ position: relative; height: 25%; background: var(--feed-bg); color: #fff; overflow: hidden;
      border-bottom: 1px solid rgba(255,255,255,0.08); }

    .canvasWrap{ position: absolute; inset: 0; }
    #chart{ width: 100%; height: 100%; display: block; }

    /* Lightweight metrics over the chart */
    .metrics{ position: absolute; top: 8px; left: 12px; right: 12px; display: flex; gap: 12px;
      font-variant-numeric: tabular-nums; font-size: clamp(10px, 2.6vw, 13px); opacity: .9; }
    .metric{ display: flex; align-items: baseline; gap: 6px; white-space: nowrap; }
    .metric .label{ color: var(--text-muted); letter-spacing: .04em; font-size: .9em; }
    .metric .value{ font-weight: 600; }
    .metric .delta{ font-size: .85em; }
    .metric .up{ color: #22c55e; }
    .metric .down{ color: #ef4444; }

    /* Bottom 75% intentionally blank */
    .playfield{ flex: 1 1 auto; background: transparent; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Game UI">
    <section class="feed" aria-label="Live feed">
      <div class="canvasWrap"><canvas id="chart" aria-hidden="true"></canvas></div>
      <div class="metrics" aria-live="polite" aria-atomic="false">
        <div class="metric"><span class="label">HR</span><span class="value" data-key="hr">72</span><span class="delta up" data-key="hrd">+0.2</span></div>
        <div class="metric"><span class="label">O2</span><span class="value" data-key="o2">98.1%</span><span class="delta down" data-key="o2d">-0.1</span></div>
        <div class="metric"><span class="label">IDX</span><span class="value" data-key="idx">4123.2</span><span class="delta up" data-key="idxd">+2.1</span></div>
        <div class="metric"><span class="label">TMP</span><span class="value" data-key="tmp">36.9°C</span><span class="delta up" data-key="tmpd">+0.0</span></div>
      </div>
    </section>

    <main class="playfield" aria-label="Game playfield" tabindex="-1"></main>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');
    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let width = 0, height = 0;
    let data = [];
    const historySeconds = 12;      // visible window width in seconds
    const samplesPerSecond = 30;     // data sampling rate
    const speed = 60;                // px per second for scroll speed
    const gridRows = 4;              // horizontal grid rows
    let lastTs = 0;
    let paused = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    function resize(){
      const r = canvas.getBoundingClientRect();
      width  = Math.floor(r.width * dpr);
      height = Math.floor(r.height * dpr);
      canvas.width = width; canvas.height = height;
      ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr, dpr);
    }

    function seed(){
      const total = historySeconds * samplesPerSecond;
      data = new Array(total).fill(0);
      let v = 0.5; // normalized [0..1]
      for(let i=0;i<total;i++){
        v = clamp01(v + (Math.random()-0.5)*0.08); // random walk
        data[i] = v;
      }
    }

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    function drawGrid(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      // verticals
      const stepX = 40;
      for(let x=0; x<=w; x+=stepX){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h); ctx.stroke(); }
      // horizontals
      const stepY = h / gridRows;
      for(let y=0; y<=h; y+=stepY){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(w,y+0.5); ctx.stroke(); }
      ctx.restore();
    }

    function drawLine(offsetPx){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const n = data.length;
      const pxPerSample = (w / historySeconds) / samplesPerSecond;
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#2dd4bf';
      ctx.beginPath();
      const y = v => h - (h*0.15) - v*(h*0.7); // leave headroom and floor
      for(let i=0;i<n;i++){
        const idx = n-1-i;          // newest on the right
        const x = w - (i*pxPerSample) - offsetPx;
        if(x < -10) break;
        const v = data[idx];
        if(i===0) ctx.moveTo(x, y(v)); else ctx.lineTo(x, y(v));
      }
      ctx.stroke();
      ctx.restore();
    }

    function tick(ts){
      if(paused) return;
      if(!lastTs) lastTs = ts;
      const dt = Math.min(64, ts - lastTs);
      lastTs = ts;
      const offset = (ts/1000 * speed) % (canvas.clientWidth / historySeconds);
      // probabilistic sample insert roughly at sampling rate
      if(Math.random() < dt / (1000/samplesPerSecond)){
        const prev = data[data.length-1];
        const next = clamp01(prev + (Math.random()-0.5)*0.1);
        data.push(next); data.shift();
        updateMetrics(prev, next);
      }
      drawGrid();
      drawLine(offset);
      requestAnimationFrame(tick);
    }

    // --- Metrics ---
    const metrics = { hr:72, o2:98.1, idx:4123.2, tmp:36.9 };
    function updateMetrics(prev, next){
      const defs = [
        ['hr',  (Math.random()*2-1)*0.6,  40,160, 0],
        ['o2',  (Math.random()*2-1)*0.05, 90,100, 1],
        ['idx', (Math.random()*2-1)*4.0,   0,1e6, 1],
        ['tmp', (Math.random()*2-1)*0.02, 34, 40, 1],
      ];
      defs.forEach(([k,d,min,max,fix])=>{
        const old = metrics[k];
        const val = Math.max(min, Math.min(max, old + d));
        const delta = +(val - old).toFixed(1);
        metrics[k] = +val.toFixed(fix);
        renderMetric(k, delta);
      });
    }

    function renderMetric(k, delta){
      const vEl = document.querySelector(`[data-key="${k}"]`);
      const dEl = document.querySelector(`[data-key="${k}d"]`);
      if(!vEl || !dEl) return;
      const v = metrics[k];
      vEl.textContent = k==='o2' ? v.toFixed(1)+'%' : k==='tmp' ? v.toFixed(1)+'°C' : k==='idx' ? v.toFixed(1) : Math.round(v);
      const sign = delta >= 0 ? '+' : '';
      dEl.textContent = sign + delta.toFixed(1);
      dEl.classList.toggle('up', delta >= 0);
      dEl.classList.toggle('down', delta < 0);
    }

    // Resize and lifecycle
    const ro = new ResizeObserver(() => { resize(); drawGrid(); });
    ro.observe(canvas.parentElement);
    window.addEventListener('orientationchange', () => { setTimeout(()=>{ dpr = Math.max(1, window.devicePixelRatio || 1); resize(); }, 200); }, { passive:true });
    document.addEventListener('visibilitychange', () => { paused = document.hidden || window.matchMedia('(prefers-reduced-motion: reduce)').matches; if(!paused){ lastTs = 0; requestAnimationFrame(tick); } });

    seed(); resize(); drawGrid(); if(!paused) requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
