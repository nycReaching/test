<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji Roguelike</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: monospace;
            background-color: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* Prevent default touch behaviors */
        }

        #game-container {
            width: 100%;
            max-width: 400px; /* Portrait mobile friendly */
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #map {
            font-size: 20px; /* Adjust emoji size */
            line-height: 1;
            white-space: pre;
            background-color: #222;
            padding: 10px;
            border: 1px solid #444;
            overflow: hidden;
            text-align: center;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #stats {
            padding: 10px;
            background-color: #333;
            border-bottom: 1px solid #444;
            text-align: center;
        }

        #inventory {
            padding: 10px;
            background-color: #333;
            border-top: 1px solid #444;
            text-align: center;
        }

        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 10px;
            background-color: #444;
        }

        button {
            font-size: 24px;
            padding: 15px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            touch-action: manipulation; /* Better touch handling */
        }

        button:hover {
            background-color: #666;
        }

        /* Portrait mode enforcement */
        @media (orientation: landscape) {
            body::before {
                content: "Please rotate to portrait mode for best experience.";
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 24px;
                text-align: center;
                z-index: 1000;
            }
            #game-container {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="stats">Health: 100 | Level: 1 | Score: 0</div>
        <div id="map"></div>
        <div id="inventory">Inventory: </div>
        <div id="controls">
            <button onclick="move('nw')">&#8598;</button>
            <button onclick="move('n')">&#8593;</button>
            <button onclick="move('ne')">&#8599;</button>
            <button onclick="move('w')">&#8592;</button>
            <button onclick="wait()">‚è∏Ô∏è</button>
            <button onclick="move('e')">&#8594;</button>
            <button onclick="move('sw')">&#8601;</button>
            <button onclick="move('s')">&#8595;</button>
            <button onclick="move('se')">&#8600;</button>
        </div>
    </div>

    <script>
        // Game constants
        const MAP_WIDTH = 15;
        const MAP_HEIGHT = 20; // Taller for portrait
        const PLAYER_EMOJI = 'üßô';
        const FLOOR_EMOJI = 'üü´';
        const WALL_EMOJI = 'üå≥';
        const ENEMY_EMOJI = 'üëπ';
        const ITEM_EMOJIS = ['üî•', 'üíß', '‚ö°', 'üåø']; // Fire, Water, Lightning, Plant for synergies
        const SYNERGY_BONUSES = {
            'üî•üíß': { name: 'Steam Blast', bonus: 20 }, // Fire + Water
            '‚ö°üåø': { name: 'Electric Vine', bonus: 15 }, // Lightning + Plant
            'üî•‚ö°': { name: 'Plasma Storm', bonus: 25 }, // Fire + Lightning
            // Add more synergies as needed
        };

        // Game state
        let map = [];
        let player = { x: Math.floor(MAP_WIDTH / 2), y: Math.floor(MAP_HEIGHT / 2), health: 100, level: 1, score: 0 };
        let enemies = [];
        let items = [];
        let inventory = [];

        function initGame() {
            generateMap();
            placeEnemies(5); // Place 5 enemies
            placeItems(10); // Place 10 items
            renderMap();
            renderStats();
            renderInventory();
        }

        function generateMap() {
            map = Array.from({ length: MAP_HEIGHT }, () => Array(MAP_WIDTH).fill(FLOOR_EMOJI));
            // Add random walls
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * MAP_WIDTH);
                const y = Math.floor(Math.random() * MAP_HEIGHT);
                if (!(x === player.x && y === player.y)) {
                    map[y][x] = WALL_EMOJI;
                }
            }
        }

        function placeEnemies(count) {
            enemies = [];
            for (let i = 0; i < count; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * MAP_WIDTH);
                    y = Math.floor(Math.random() * MAP_HEIGHT);
                } while (map[y][x] !== FLOOR_EMOJI || (x === player.x && y === player.y));
                enemies.push({ x, y, health: 20 });
            }
        }

        function placeItems(count) {
            items = [];
            for (let i = 0; i < count; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * MAP_WIDTH);
                    y = Math.floor(Math.random() * MAP_HEIGHT);
                } while (map[y][x] !== FLOOR_EMOJI || (x === player.x && y === player.y));
                const item = ITEM_EMOJIS[Math.floor(Math.random() * ITEM_EMOJIS.length)];
                items.push({ x, y, emoji: item });
            }
        }

        function renderMap() {
            let mapStr = '';
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (x === player.x && y === player.y) {
                        mapStr += PLAYER_EMOJI;
                    } else {
                        const enemy = enemies.find(e => e.x === x && e.y === y);
                        if (enemy) {
                            mapStr += ENEMY_EMOJI;
                        } else {
                            const item = items.find(i => i.x === x && i.y === y);
                            if (item) {
                                mapStr += item.emoji;
                            } else {
                                mapStr += map[y][x];
                            }
                        }
                    }
                }
                mapStr += '\n';
            }
            document.getElementById('map').innerText = mapStr;
        }

        function renderStats() {
            document.getElementById('stats').innerText = `Health: ${player.health} | Level: ${player.level} | Score: ${player.score}`;
        }

        function renderInventory() {
            document.getElementById('inventory').innerText = `Inventory: ${inventory.join(' ')}`;
        }

        function move(dir) {
            let dx = 0, dy = 0;
            switch (dir) {
                case 'n': dy = -1; break;
                case 's': dy = 1; break;
                case 'w': dx = -1; break;
                case 'e': dx = 1; break;
                case 'nw': dx = -1; dy = -1; break;
                case 'ne': dx = 1; dy = -1; break;
                case 'sw': dx = -1; dy = 1; break;
                case 'se': dx = 1; dy = 1; break;
            }

            const nx = player.x + dx;
            const ny = player.y + dy;

            if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT || map[ny][nx] === WALL_EMOJI) {
                return; // Invalid move
            }

            // Check for item
            const itemIndex = items.findIndex(i => i.x === nx && i.y === ny);
            if (itemIndex !== -1) {
                const item = items[itemIndex];
                inventory.push(item.emoji);
                items.splice(itemIndex, 1);
                player.score += 10;
                checkSynergies();
            }

            // Check for enemy
            const enemyIndex = enemies.findIndex(e => e.x === nx && e.y === ny);
            if (enemyIndex !== -1) {
                const enemy = enemies[enemyIndex];
                enemy.health -= 10 + (player.level * 5); // Basic attack + level bonus
                if (enemy.health <= 0) {
                    enemies.splice(enemyIndex, 1);
                    player.score += 50;
                    player.level += 0.1; // Incremental level up
                } else {
                    player.health -= 10; // Enemy counterattack
                    if (player.health <= 0) {
                        alert('Game Over! Score: ' + player.score);
                        initGame();
                        return;
                    }
                }
            } else {
                // Move player if no enemy
                player.x = nx;
                player.y = ny;
            }

            // Enemy turns: simple chase
            enemies.forEach(enemy => {
                const dx = Math.sign(player.x - enemy.x);
                const dy = Math.sign(player.y - enemy.y);
                const ex = enemy.x + dx;
                const ey = enemy.y + dy;
                if (ex === player.x && ey === player.y) {
                    player.health -= 10;
                    if (player.health <= 0) {
                        alert('Game Over! Score: ' + player.score);
                        initGame();
                        return;
                    }
                } else if (map[ey][ex] === FLOOR_EMOJI) {
                    enemy.x = ex;
                    enemy.y = ey;
                }
            });

            renderMap();
            renderStats();
            renderInventory();

            // Check win condition (e.g., clear all enemies)
            if (enemies.length === 0) {
                alert('Level Cleared! Proceeding to next level.');
                player.level++;
                initGame();
            }
        }

        function wait() {
            // Skip turn, enemies move
            enemies.forEach(enemy => {
                const dx = Math.sign(player.x - enemy.x);
                const dy = Math.sign(player.y - enemy.y);
                const ex = enemy.x + dx;
                const ey = enemy.y + dy;
                if (ex === player.x && ey === player.y) {
                    player.health -= 10;
                    if (player.health <= 0) {
                        alert('Game Over! Score: ' + player.score);
                        initGame();
                        return;
                    }
                } else if (map[ey][ex] === FLOOR_EMOJI) {
                    enemy.x = ex;
                    enemy.y = ey;
                }
            });
            renderMap();
            renderStats();
        }

        function checkSynergies() {
            // Sort inventory to check combinations
            const sortedInv = [...inventory].sort().join('');
            for (const combo in SYNERGY_BONUSES) {
                if (sortedInv.includes(combo)) {
                    const bonus = SYNERGY_BONUSES[combo];
                    player.score += bonus.bonus;
                    alert(`Synergy Unlocked: ${bonus.name}! +${bonus.bonus} score`);
                    // Remove used items (simple: remove the combo items)
                    for (const char of combo) {
                        const idx = inventory.indexOf(char);
                        if (idx !== -1) inventory.splice(idx, 1);
                    }
                }
            }
            renderInventory();
        }

        initGame();
    </script>
</body>
</html>
