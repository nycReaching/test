<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 
      This meta tag is CRITICAL for mobile. 
      - width=device-width sets the width to the device's screen.
      - initial-scale=1.0 prevents default zoom.
      - user-scalable=no stops the user from pinching to zoom, which is good for a game.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Isometric Game UI</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Basic Setup --- */
        html, body {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', 'Roboto', sans-serif;
            background-color: #000000;
            color: #ffffff;
            /* Prevents scrolling, pull-to-refresh, etc. */
            overflow: hidden; 
        }

        body {
            /* This is the key for full mobile compatibility.
              100dvh = 100% of the *dynamic* viewport height.
              It resizes when mobile URL bars and nav bars appear/disappear.
            */
            height: 100dvh;
            
            /* Main layout: Game area on top, controls on bottom */
            display: flex;
            flex-direction: column;
        }

        /* --- Game Area --- */
        #game-area {
            /* This makes the game area fill all available space */
            flex: 1;
            display: grid;
            place-items: center;
            overflow: hidden;
            
            /* Adds 3D perspective, which makes the isometric tilt look better */
            perspective: 800px;
        }

        #iso-wrapper {
            position: relative;
            /* This is the isometric transform: tilt forward, then rotate */
            transform: rotateX(60deg) rotateZ(-45deg);
            transform-style: preserve-3d;
            /* Add a transition for smooth movement (optional) */
            transition: transform 0.1s linear;
            /* Set origin for scaling */
            transform-origin: center;
        }

        #grid {
            display: grid;
            /* Grid size will be set by JS */
            border-left: 1px solid #333; /* Outer border */
            border-top: 1px solid #333;  /* Outer border */
            transform-style: preserve-3d;
        }

        .grid-cell {
            /* Cell size will be set by JS */
            box-sizing: border-box; /* Ensures border is inside the element */
            border-right: 1px solid #333;
            border-bottom: 1px solid #333;
            /* Add a subtle feedback on tap */
            transition: background-color 0.1s;
        }

        .grid-cell:active {
            background-color: rgba(255, 255, 255, 0.2);
        }

        #player {
            position: absolute;
            top: 0;
            left: 0;
            /* Size matches grid cells */
            background-color: #00ff00;
            box-shadow: 0 0 15px #00ff00, 0 0 5px #ffffff;
            
            /* Lifts the player slightly above the grid lines */
            transform: translateZ(2px);
            
            /* Smooth movement */
            transition: transform 0.1s linear;
        }

        /* --- Control Area (Removed) --- */

    </style>
</head>
<body>

    <!-- Game Area: This will fill the top portion -->
    <div id="game-area">
        <div id="iso-wrapper">
            <!-- The grid lines will be generated by JS into here -->
            <div id="grid"></div>
            
            <!-- The player cube (a simple div) -->
            <div id="player"></div>
        </div>
    </div>

    <!-- Control Area (Removed) -->

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Game State & Constants ---
            const GRID_SIZE = 10; // 10x10 grid
            const CELL_SIZE = 40; // 40px cells (fixed size)
            
            // Player position (1-indexed, so 1 to 10)
            let playerX = 5;
            let playerY = 5;

            // --- Pan & Zoom State ---
            let currentScale = 1.0;
            let currentPanX = 0;
            let currentPanY = 0;
            let isPanning = false;
            let lastPanX = 0;
            let lastPanY = 0;
            let isPinching = false;
            let lastPinchDist = 0;

            // --- Element References ---
            const grid = document.getElementById('grid');
            const player = document.getElementById('player');
            const gameArea = document.getElementById('game-area'); // Get game area

            // --- Initialization ---
            function initGame() {
                // 1. Setup Grid CSS
                grid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
                grid.style.gridTemplateRows = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
                player.style.width = `${CELL_SIZE}px`;
                player.style.height = `${CELL_SIZE}px`;

                // 2. Generate Grid Cells
                // Clear any existing cells (for re-runs)
                grid.innerHTML = ''; 
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.style.width = `${CELL_SIZE}px`;
                    cell.style.height = `${CELL_SIZE}px`;

                    // Store coordinates (1-indexed)
                    const x = (i % GRID_SIZE) + 1;
                    const y = Math.floor(i / GRID_SIZE) + 1;
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    // Add tap listener
                    cell.addEventListener('touchstart', (e) => {
                        // Prevent this tap from being interpreted as a pan
                        e.stopPropagation(); 
                        
                        // Only handle single taps
                        if (e.touches.length > 1) return;
                        
                        // Get coords and move player
                        const targetX = parseInt(e.currentTarget.dataset.x, 10);
                        const targetY = parseInt(e.currentTarget.dataset.y, 10);
                        movePlayerTo(targetX, targetY);
                    }, { passive: true }); // passive: true for performance

                    grid.appendChild(cell);
                }

                // 3. Set initial player position
                updatePlayerPosition();
                
                // 4. Attach Pan/Zoom Listeners to game area
                gameArea.addEventListener('touchstart', onTouchStart);
                gameArea.addEventListener('touchmove', onTouchMove, { passive: false }); // Need false to preventDefault
                gameArea.addEventListener('touchend', onTouchEnd);
                gameArea.addEventListener('touchcancel', onTouchEnd);
            }

            // --- Game Logic ---
            
            /**
             * Updates the player's visual position on the grid.
             */
            function updatePlayerPosition() {
                // Calculate the pixel position. (playerX-1) because position is 1-indexed.
                const xPos = (playerX - 1) * CELL_SIZE;
                const yPos = (playerY - 1) * CELL_SIZE;

                // Use CSS transform to move the player.
                // We add translateZ(2px) to keep it lifted above the grid lines.
                player.style.transform = `translate(${xPos}px, ${yPos}px) translateZ(2px)`;
            }

            /**
             * Moves the player to a specific (x, y) coordinate.
             * x: Target X (1 to 10)
             * y: Target Y (1 to 10)
             */
            function movePlayerTo(x, y) {
                // Boundary Check: Ensure the new position is within the grid (1 to GRID_SIZE)
                if (x >= 1 && x <= GRID_SIZE && y >= 1 && y <= GRID_SIZE) {
                    // Valid move: Update state
                    playerX = x;
                    playerY = y;
                    
                    // Update the visual position
                    updatePlayerPosition();
                }
                // If it's not a valid move, do nothing.
            }
            
            // --- Pan & Zoom Functions ---

            /**
             * Applies current pan and scale to the iso-wrapper.
             */
            function updateWrapperTransform() {
                const wrapper = document.getElementById('iso-wrapper');
                wrapper.style.transform = 
                    `translate(${currentPanX}px, ${currentPanY}px) ` +
                    `rotateX(60deg) rotateZ(-45deg) ` +
                    `scale(${currentScale})`;
            }

            /**
             * Calculates distance between two touch points.
             */
            function getDist(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function onTouchStart(e) {
                if (e.touches.length === 1) {
                    // Start Panning
                    isPanning = true;
                    lastPanX = e.touches[0].clientX;
                    lastPanY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    // Start Pinching
                    isPinching = true;
                    isPanning = false; // Stop panning when pinch starts
                    lastPinchDist = getDist(e.touches[0], e.touches[1]);
                }
            }

            function onTouchMove(e) {
                // Prevent default browser scroll/zoom
                e.preventDefault(); 

                if (isPinching && e.touches.length === 2) {
                    // Handle Pinch
                    const newDist = getDist(e.touches[0], e.touches[1]);
                    const deltaDist = newDist - lastPinchDist;
                    
                    // Adjust scale (zooming in/out)
                    // The 0.005 is a sensitivity multiplier, adjust as needed
                    currentScale += deltaDist * 0.005; 
                    
                    // Add constraints to scale
                    if (currentScale < 0.5) currentScale = 0.5;
                    if (currentScale > 3.0) currentScale = 3.0;

                    lastPinchDist = newDist;
                    updateWrapperTransform();

                } else if (isPanning && e.touches.length === 1) {
                    // Handle Pan
                    const newX = e.touches[0].clientX;
                    const newY = e.touches[0].clientY;

                    const deltaX = newX - lastPanX;
                    const deltaY = newY - lastPanY;

                    currentPanX += deltaX;
                    currentPanY += deltaY;

                    lastPanX = newX;
                    lastPanY = newY;
                    updateWrapperTransform();
                }
            }

            function onTouchEnd(e) {
                if (e.touches.length < 2) {
                    isPinching = false;
                }
                if (e.touches.length < 1) {
                    isPanning = false;
                }
            }
            
            // --- (Removed) Prevent double-tap zoom on controls ---

            // Start the game
            initGame();

            // --- (Removed) Handle Resize / Orientation Change ---
        });
    </script>
</body>
</html>
