<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 
      This meta tag is CRITICAL for mobile. 
      - width=device-width sets the width to the device's screen.
      - initial-scale=1.0 prevents default zoom.
      - user-scalable=no stops the user from pinching to zoom, which is good for a game.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Isometric Game UI</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Basic Setup --- */
        html, body {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', 'Roboto', sans-serif;
            background-color: #000000;
            color: #ffffff;
            /* Prevents scrolling, pull-to-refresh, etc. */
            overflow: hidden; 
        }

        body {
            /* This is the key for full mobile compatibility.
              100dvh = 100% of the *dynamic* viewport height.
              It resizes when mobile URL bars and nav bars appear/disappear.
            */
            height: 100dvh;
            
            /* Main layout: Game area on top, controls on bottom */
            display: flex;
            flex-direction: column;
        }

        /* --- Game Area --- */
        #game-area {
            /* This makes the game area fill all available space */
            flex: 1;
            display: grid;
            place-items: center;
            overflow: hidden;
            
            /* Adds 3D perspective, which makes the isometric tilt look better */
            perspective: 800px;
        }

        #iso-wrapper {
            position: relative;
            /* This is the isometric transform: tilt forward, then rotate */
            transform: rotateX(60deg) rotateZ(-45deg);
            transform-style: preserve-3d;
            /* Add a transition for smooth movement (optional) */
            transition: transform 0.1s linear;
        }

        #grid {
            display: grid;
            /* Grid size will be set by JS */
            border-left: 1px solid #333; /* Outer border */
            border-top: 1px solid #333;  /* Outer border */
            transform-style: preserve-3d;
        }

        .grid-cell {
            /* Cell size will be set by JS */
            box-sizing: border-box; /* Ensures border is inside the element */
            border-right: 1px solid #333;
            border-bottom: 1px solid #333;
        }

        #player {
            position: absolute;
            top: 0;
            left: 0;
            /* Size matches grid cells */
            background-color: #00ff00;
            box-shadow: 0 0 15px #00ff00, 0 0 5px #ffffff;
            
            /* Lifts the player slightly above the grid lines */
            transform: translateZ(2px);
            
            /* Smooth movement */
            transition: transform 0.1s linear;
        }

        /* --- Control Area --- */
        #controls {
            /* This area will not grow, but will not shrink below its content */
            flex-shrink: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: #111;
            border-top: 1px solid #333;
            
            /* Center the D-pad */
            display: grid;
            place-items: center;
        }

        .d-pad {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            grid-template-columns: 70px 70px 70px;
            grid-template-rows: 70px 70px 70px;
            gap: 5px;
        }

        .control-btn {
            background-color: #444;
            border: 1px solid #666;
            border-radius: 12px;
            
            /* Center the arrow icon */
            display: grid;
            place-items: center;
            
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            
            /* Prevents text selection on repeated taps */
            user-select: none;
            
            /* Makes it feel responsive */
            cursor: pointer;
            transition: background-color 0.1s;
        }

        /* Active state for tapping */
        .control-btn:active {
            background-color: #666;
        }

        /* Assign buttons to grid areas */
        #btn-up { grid-area: up; }
        #btn-left { grid-area: left; }
        #btn-right { grid-area: right; }
        #btn-down { grid-area: down; }

    </style>
</head>
<body>

    <!-- Game Area: This will fill the top portion -->
    <div id="game-area">
        <div id="iso-wrapper">
            <!-- The grid lines will be generated by JS into here -->
            <div id="grid"></div>
            
            <!-- The player cube (a simple div) -->
            <div id="player"></div>
        </div>
    </div>

    <!-- Control Area: This will be fixed at the bottom -->
    <div id="controls">
        <div class="d-pad">
            <div class="control-btn" id="btn-up">&uarr;</div>
            <div class="control-btn" id="btn-left">&larr;</div>
            <div class="control-btn"id="btn-right">&rarr;</div>
            <div class="control-btn" id="btn-down">&darr;</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Game State & Constants ---
            const GRID_SIZE = 10; // 10x10 grid
            const CELL_SIZE = 40; // 40px cells
            
            // Player position (1-indexed, so 1 to 10)
            let playerX = 5;
            let playerY = 5;

            // --- Element References ---
            const grid = document.getElementById('grid');
            const player = document.getElementById('player');

            // --- Initialization ---
            function initGame() {
                // 1. Setup Grid CSS
                grid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
                grid.style.gridTemplateRows = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
                player.style.width = `${CELL_SIZE}px`;
                player.style.height = `${CELL_SIZE}px`;

                // 2. Generate Grid Cells
                // Clear any existing cells (for re-runs)
                grid.innerHTML = ''; 
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.style.width = `${CELL_SIZE}px`;
                    cell.style.height = `${CELL_SIZE}px`;
                    grid.appendChild(cell);
                }

                // 3. Set initial player position
                updatePlayerPosition();
                
                // 4. Attach Control Listeners
                // We use 'mousedown' for quicker response than 'click'
                document.getElementById('btn-up').addEventListener('click', () => movePlayer(0, -1));
                document.getElementById('btn-down').addEventListener('click', () => movePlayer(0, 1));
                document.getElementById('btn-left').addEventListener('click', () => movePlayer(-1, 0));
                document.getElementById('btn-right').addEventListener('click', () => movePlayer(1, 0));
            }

            // --- Game Logic ---
            
            /**
             * Updates the player's visual position on the grid.
             */
            function updatePlayerPosition() {
                // Calculate the pixel position. (playerX-1) because position is 1-indexed.
                const xPos = (playerX - 1) * CELL_SIZE;
                const yPos = (playerY - 1) * CELL_SIZE;

                // Use CSS transform to move the player.
                // We add translateZ(2px) to keep it lifted above the grid lines.
                player.style.transform = `translate(${xPos}px, ${yPos}px) translateZ(2px)`;
            }

            /**
             * Moves the player by a delta (dx, dy) and updates the view.
             * dx: Change in X (-1, 0, or 1)
             * dy: Change in Y (-1, 0, or 1)
             */
            function movePlayer(dx, dy) {
                const newX = playerX + dx;
                const newY = playerY + dy;

                // Boundary Check: Ensure the new position is within the grid (1 to GRID_SIZE)
                if (newX >= 1 && newX <= GRID_SIZE && newY >= 1 && newY <= GRID_SIZE) {
                    // Valid move: Update state
                    playerX = newX;
                    playerY = newY;
                    
                    // Update the visual position
                    updatePlayerPosition();
                }
                // If it's not a valid move, do nothing.
            }
            
            // --- Prevent double-tap zoom on controls ---
            // This is a common issue on mobile web games.
            document.getElementById('controls').addEventListener('touchstart', (e) => {
                // Only prevent default if tapping a button
                if (e.target.classList.contains('control-btn')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Start the game
            initGame();
        });
    </script>
</body>
</html>
