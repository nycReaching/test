<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Minimal Isometric RPG Starter (HTML/CSS/JS only)</title>
  <style>
    html, body { margin:0; height:100%; background:#0f1115; overscroll-behavior:none; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    /* On-screen D-pad */
    .dpad { position:fixed; left:16px; bottom:16px; display:grid; grid-template-columns:repeat(3,56px); grid-gap:8px; }
    .dpad button {
      width:56px; height:56px; border:none; border-radius:14px;
      background:#1e2633; color:#cbd5e1; font:600 18px/1 system-ui; outline:none;
      box-shadow:0 4px 14px rgba(0,0,0,.35);
    }
    .dpad button:active { transform:translateY(1px); }
    .legend { position:fixed; right:12px; bottom:12px; color:#9fb3c8; font:12px/1.2 system-ui; text-align:right; opacity:.85 }
    .legend kbd{background:#243041;border-radius:4px;padding:2px 5px;font:600 11px/1 system-ui;color:#cfe3ff}
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Simple D-pad for touch -->
  <div class="dpad" aria-hidden="false">
    <span></span><button data-dir="up">▲</button><span></span>
    <button data-dir="left">◀</button><button data-dir="down">▼</button><button data-dir="right">▶</button>
  </div>
  <div class="legend">
    Move: <kbd>W</kbd>/<kbd>A</kbd>/<kbd>S</kbd>/<kbd>D</kbd> or tap<br/>
    One HTML file. No libraries.
  </div>

<script>
(() => {
  // --- Canvas setup with devicePixelRatio for crisp rendering (mobile + HiDPI).
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { innerWidth:wCSS, innerHeight:hCSS } = window;
    canvas.width  = Math.floor(wCSS * dpr);
    canvas.height = Math.floor(hCSS * dpr);
    canvas.style.width  = wCSS + 'px';
    canvas.style.height = hCSS + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0); // Use CSS pixels in drawing code
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // --- Isometric tile settings.
  const TILE_W = 64;          // width of diamond
  const TILE_H = 32;          // height of diamond
  const STEP_Z = 16;          // vertical step visual size
  const MAP_W = 12, MAP_H = 12;

  // Tiny heightmap. 0..3 with a few raised platforms.
  const map = Array.from({length:MAP_H}, (_,y)=>Array.from({length:MAP_W}, (_,x)=>{
    const r = (Math.sin(x*0.7)+Math.cos(y*0.6))*0.6 + (x>7 && y>3 && y<9 ? 1.2:0);
    return Math.max(0, Math.min(3, (r|0)));
  }));

  // Center camera in screen space
  function screenCenter() {
    return { cx: canvas.clientWidth * 0.5, cy: canvas.clientHeight * 0.42 };
  }

  // Map -> screen projection
  function mapToScreen(x, y, z=0) {
    const { cx, cy } = screenCenter();
    const sx = (x - y) * (TILE_W / 2);
    const sy = (x + y) * (TILE_H / 2) - z * STEP_Z;
    return { x: cx + sx, y: cy + sy };
  }

  // Draw a single extruded tile at (x,y) with height h
  function drawTile(x, y, h) {
    const base = mapToScreen(x, y, 0);
    const top  = mapToScreen(x, y, h);

    // Top diamond
    ctx.beginPath();
    ctx.moveTo(top.x,                 top.y - TILE_H/2);
    ctx.lineTo(top.x + TILE_W/2,      top.y);
    ctx.lineTo(top.x,                 top.y + TILE_H/2);
    ctx.lineTo(top.x - TILE_W/2,      top.y);
    ctx.closePath();
    ctx.fillStyle = colorTop(h);
    ctx.fill();

    // Right face
    ctx.beginPath();
    ctx.moveTo(top.x + TILE_W/2, top.y);
    ctx.lineTo(base.x + TILE_W/2, base.y);
    ctx.lineTo(base.x,            base.y + TILE_H/2);
    ctx.lineTo(top.x,             top.y + TILE_H/2);
    ctx.closePath();
    ctx.fillStyle = colorRight(h);
    ctx.fill();

    // Left face
    ctx.beginPath();
    ctx.moveTo(top.x - TILE_W/2, top.y);
    ctx.lineTo(base.x - TILE_W/2, base.y);
    ctx.lineTo(base.x,            base.y + TILE_H/2);
    ctx.lineTo(top.x,             top.y + TILE_H/2);
    ctx.closePath();
    ctx.fillStyle = colorLeft(h);
    ctx.fill();
  }

  // Simple palette by height
  function colorTop(h){  return ['#3a5f7a','#3f6d8d','#447aa0','#4c86b1'][h] || '#3a5f7a'; }
  function colorLeft(h){ return ['#2a4760','#2f5270','#335c7f','#39658d'][h] || '#2a4760'; }
  function colorRight(h){return ['#203a50','#24435d','#284c69','#2d5474'][h] || '#203a50'; }

  // Player
  const player = { x: 3, y: 3, z: () => map[player.y][player.x], ox:0, oy:0, anim:0, moving:false, target:null };

  function tryMove(dx, dy) {
    if (player.moving) return;
    const nx = player.x + dx, ny = player.y + dy;
    if (nx < 0 || ny < 0 || nx >= MAP_W || ny >= MAP_H) return;
    // Permit step up/down by 1
    const dz = map[ny][nx] - map[player.y][player.x];
    if (Math.abs(dz) > 1) return;
    player.moving = true;
    player.target = { x:nx, y:ny };
    player.anim = 0;
  }

  // Input: keyboard
  const keyMap = { ArrowUp:[0,-1], KeyW:[0,-1], ArrowDown:[0,1], KeyS:[0,1], ArrowLeft:[-1,0], KeyA:[-1,0], ArrowRight:[1,0], KeyD:[1,0] };
  window.addEventListener('keydown', (e) => {
    const v = keyMap[e.code];
    if (!v) return;
    e.preventDefault();
    tryMove(v[0], v[1]);
  });

  // Input: touch d-pad
  document.querySelectorAll('.dpad button').forEach(btn=>{
    btn.addEventListener('pointerdown', (e)=>{
      const d = e.currentTarget.dataset.dir;
      if (d==='up') tryMove(0,-1);
      if (d==='down') tryMove(0,1);
      if (d==='left') tryMove(-1,0);
      if (d==='right') tryMove(1,0);
    });
  });

  // Draw player as a tiny cube
  function drawPlayer(t) {
    // Interpolate during movement
    let px = player.x, py = player.y;
    if (player.moving && player.target) {
      const dur = 140; // ms
      const f = Math.min(1, player.anim / dur);
      const ease = f<.5 ? 2*f*f : -1+(4-2*f)*f; // easeInOutQuad
      px = lerp(player.x, player.target.x, ease);
      py = lerp(player.y, player.target.y, ease);
      if (f >= 1) {
        player.x = player.target.x;
        player.y = player.target.y;
        player.moving = false;
        player.target = null;
      }
    }

    const baseH = sampleHeightBilinear(px, py);
    const p = mapToScreen(px, py, baseH + 0.6 + 0.05*Math.sin(t*0.004)); // slight bob
    const w = 28, h = 16, z = 14;

    // top
    ctx.beginPath();
    ctx.moveTo(p.x,         p.y - h/2);
    ctx.lineTo(p.x + w/2,   p.y);
    ctx.lineTo(p.x,         p.y + h/2);
    ctx.lineTo(p.x - w/2,   p.y);
    ctx.closePath();
    ctx.fillStyle = '#ffd166';
    ctx.fill();

    // right
    ctx.beginPath();
    ctx.moveTo(p.x + w/2, p.y);
    ctx.lineTo(p.x + w/2, p.y + z);
    ctx.lineTo(p.x,       p.y + z + h/2);
    ctx.lineTo(p.x,       p.y + h/2);
    ctx.closePath();
    ctx.fillStyle = '#e6b653';

    ctx.fill();

    // left
    ctx.beginPath();
    ctx.moveTo(p.x - w/2, p.y);
    ctx.lineTo(p.x - w/2, p.y + z);
    ctx.lineTo(p.x,       p.y + z + h/2);
    ctx.lineTo(p.x,       p.y + h/2);
    ctx.closePath();
    ctx.fillStyle = '#c49c47';
    ctx.fill();
  }

  function lerp(a,b,t){ return a + (b-a)*t; }

  // Sample height smoothly for animation between tiles
  function sampleHeightBilinear(x, y){
    const x0 = Math.floor(x), y0 = Math.floor(y);
    const x1 = Math.min(MAP_W-1, x0+1), y1 = Math.min(MAP_H-1, y0+1);
    const hx0y0 = map[y0][x0];
    const hx1y0 = map[y0][x1];
    const hx0y1 = map[y1][x0];
    const hx1y1 = map[y1][x1];
    const tx = x - x0, ty = y - y0;
    const a = lerp(hx0y0, hx1y0, tx);
    const b = lerp(hx0y1, hx1y1, tx);
    return lerp(a,b,ty);
  }

  // Main loop
  let prevT = performance.now();
  function frame(t){
    const dt = t - prevT; prevT = t;
    if (player.moving) player.anim += dt;

    // Clear
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    // Draw map in correct painter's order
    for (let y=0; y<MAP_H; y++){
      for (let x=0; x<MAP_W; x++){
        drawTile(x,y, map[y][x]);
      }
    }
    drawPlayer(t);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
