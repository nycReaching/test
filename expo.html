<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Isometric Voxel UI</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use the Inter font */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* This container provides the 3D perspective */
        #game-world-wrapper {
            perspective: 1000px;
        }

        /* This container is rotated to create the isometric view */
        #iso-world {
            transform-style: preserve-3d;
            transform: rotateX(60deg) rotateZ(45deg);
        }

        /* The "ground" plane */
        #game-area {
            width: 300px;
            height: 300px;
            background: #34d399; /* emerald-400 */
            /* Add a grid pattern for a "tile" feel */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            /* Give the ground some "thickness" */
            box-shadow: 0px 0px 0px 8px #10b981; /* emerald-600 */
            position: absolute;
            top: 50%;
            left: 50%;
            /* Center the plane */
            transform: translate(-50%, -50%);
        }

        /* The player icon, styled to look like a simple voxel */
        #player {
            width: 20px;
            height: 20px;
            background: #ef4444; /* red-500 */
            position: absolute;
            top: 50%;
            left: 50%;
            /* Start at 0,0 (center of the area) */
            /* We use calc() to combine centering with JS-driven translation */
            transform: translate(calc(-50% + 0px), calc(-50% + 0px));
            transition: transform 0.05s linear;
            
            /* Simple 3D effect using borders */
            border-bottom: 4px solid #b91c1c; /* red-800 */
            border-right: 2px solid #dc2626; /* red-600 */
            box-sizing: border-box; /* Include border in width/height */
        }

        /* Base styling for control buttons */
        .control-btn {
            background-color: #4b5563; /* gray-600 */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.1s;
            /* Disable user selection and tap highlights for a native feel */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        /* Active state for a responsive feel */
        .control-btn:active {
            background-color: #6b7280; /* gray-500 */
        }

        /* New center button */
        #btn-action {
            background-color: #3b82f6; /* blue-500 */
        }
        #btn-action:active {
            background-color: #60a5fa; /* blue-400 */
        }
    </style>
</head>
<body class="bg-gray-800 text-white overflow-hidden">

    <!-- Main game container, laid out for portrait mobile -->
    <div id="game-container" class="flex flex-col h-screen w-screen">

        <!-- Header -->
        <header class="w-full text-center p-4 bg-gray-900 shadow-lg z-10">
            <h1 class="text-xl font-bold">Iso-Voxel World</h1>
        </header>

        <!-- Game World Wrapper: This centers the iso-world and applies perspective -->
        <main id="game-world-wrapper" class="flex-grow w-full flex items-center justify-center overflow-hidden">
            
            <!-- Isometric World: This container is rotated -->
            <div id="iso-world" class="relative">
                
                <!-- Game Area: The ground plane -->
                <div id="game-area"></div>
                
                <!-- Player Icon -->
                <div id="player"></div>

            </div>
        </main>

        <!-- UI Controls -->
        <footer id="controls" class="w-full p-6 bg-gray-900 shadow-inner z-10">
            <div class="flex justify-center">
                <!-- D-Pad layout using a simple grid -->
                <div class="grid grid-cols-3 gap-1 w-36 text-2xl font-bold"> <!-- Reduced size and text -->
                    <!-- Row 1 -->
                    <div></div> <!-- Top-left empty -->
                    <button id="btn-up" class="control-btn w-full h-12 rounded-t-lg">&uarr;</button> <!-- Reduced size -->
                    <div></div> <!-- Top-right empty -->

                    <!-- Row 2 -->
                    <button id="btn-left" class="control-btn h-12 rounded-l-lg">&larr;</button> <!-- Reduced size -->
                    
                    <!-- New Center Button -->
                    <button id="btn-action" class="control-btn h-12 rounded-full">A</button> 
                    
                    <button id="btn-right" class="control-btn h-12 rounded-r-lg">&rarr;</button> <!-- Reduced size -->

                    <!-- Row 3 -->
                    <div></div> <!-- Bottom-left empty -->
                    <button id="btn-down" class="control-btn w-full h-12 rounded-b-lg">&darr;</button> <!-- Reduced size -->
                    <div></div> <!-- Bottom-right empty -->
                </div>
            </div>
        </footer>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const player = document.getElementById('player');
            const btnUp = document.getElementById('btn-up');
            const btnDown = document.getElementById('btn-down');
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            const btnAction = document.getElementById('btn-action'); // Get the new button

            // Game constants
            const MOVE_SPEED = 5; // Pixels to move per step
            const AREA_WIDTH = 300;
            const AREA_HEIGHT = 300;
            const PLAYER_WIDTH = 20;
            const PLAYER_HEIGHT = 20;

            // Calculate movement boundaries
            // The player's (x,y) state is its center, so we stop
            // when its edge reaches the edge of the area.
            const minX = -AREA_WIDTH / 2 + PLAYER_WIDTH / 2;
            const maxX = AREA_WIDTH / 2 - PLAYER_WIDTH / 2;
            const minY = -AREA_HEIGHT / 2 + PLAYER_HEIGHT / 2;
            const maxY = AREA_HEIGHT / 2 - PLAYER_HEIGHT / 2;

            // Player's state (position is relative to the center of the game area)
            const playerState = {
                x: 0,
                y: 0,
                // Track which buttons are held down
                holding: { up: false, down: false, left: false, right: false }
            };

            // Updates the player's CSS transform based on its state
            function updatePlayerPosition() {
                // By moving the player with translate(x, y) *inside* the
                // rotated #iso-world, the movement appears to be
                // along the isometric axes.
                player.style.transform = `translate(calc(-50% + ${playerState.x}px), calc(-50% + ${playerState.y}px))`;
            }

            // Game loop to handle continuous movement
            function gameLoop() {
                let dx = 0;
                let dy = 0;

                if (playerState.holding.up) dy -= MOVE_SPEED;
                if (playerState.holding.down) dy += MOVE_SPEED;
                if (playerState.holding.left) dx -= MOVE_SPEED;
                if (playerState.holding.right) dx += MOVE_SPEED;

                if (dx !== 0 || dy !== 0) {
                    // Calculate new position
                    const newX = playerState.x + dx;
                    const newY = playerState.y + dy;

                    // Clamp position within boundaries
                    playerState.x = Math.max(minX, Math.min(maxX, newX));
                    playerState.y = Math.max(minY, Math.min(maxY, newY));

                    updatePlayerPosition();
                }

                // Continue the loop
                requestAnimationFrame(gameLoop);
            }

            // --- Event Listeners ---

            // We use mousedown/mouseup and touchstart/touchend to allow
            // for "holding" the button down, which is better for games.

            function createButtonListeners(button, direction) {
                // Set 'holding' state to true
                function onPress(e) {
                    e.preventDefault(); // Prevent scrolling/zooming
                    playerState.holding[direction] = true;
                }

                // Set 'holding' state to false
                function onRelease(e) {
                    e.preventDefault();
                    playerState.holding[direction] = false;
                }

                // Mouse events
                button.addEventListener('mousedown', onPress);
                button.addEventListener('mouseup', onRelease);
                button.addEventListener('mouseleave', onRelease); // Stop if mouse leaves button

                // Touch events
                button.addEventListener('touchstart', onPress, { passive: false });
                button.addEventListener('touchend', onRelease, { passive: false });
                button.addEventListener('touchcancel', onRelease, { passive: false });
            }

            createButtonListeners(btnUp, 'up');
            createButtonListeners(btnDown, 'down');
            createButtonListeners(btnLeft, 'left');
            createButtonListeners(btnRight, 'right');

            // --- New listener for the action button ---
            // This just logs to the console for now to show it's "tappable"
            function onActionPress(e) {
                e.preventDefault();
                console.log('Action Button Pressed!');
                // You could add a 'jump' or 'action' state here
            }
            
            btnAction.addEventListener('mousedown', onActionPress);
            btnAction.addEventListener('touchstart', onActionPress, { passive: false });


            // Prevent context menu on long-press (common on mobile)
            window.addEventListener('contextmenu', (e) => e.preventDefault());

            // Start the game loop
            updatePlayerPosition(); // Set initial position
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
