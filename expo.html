<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Minimal Game UI</title>
    <style>
      :root {
        --blue: #1e90ff;
        --line-blue: #0b3a6f; /* darker center line */
        --border: 0px;        /* no outer border spacing */
        --bar-h: clamp(4px, 2.5vh, 12px);
        --btn: clamp(44px, 9vh, 72px);
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }

      body {
        margin: 0;
        background: #000; /* black background */
        /* Robust full-viewport sizing on mobile */
        min-height: 100dvh;
        min-height: 100svh;
        min-height: calc(var(--vh, 1vh) * 100);
      }

      /* Safe-area wrapper for notches */
      .wrap {
        position: fixed;
        inset: 0;
        padding-top: env(safe-area-inset-top);
        padding-right: env(safe-area-inset-right);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        overflow: hidden;
      }

      /* Blue border frame */
      .frame { display: none; }

      /* Slim horizontal middle section */
      .mid {
        position: absolute;
        left: 0;
        right: 0;
        top: 50%;
        height: 0; /* line only */
        transform: translateY(-50%);
        border-top: 3px solid var(--line-blue); /* darker blue line */
        background: transparent;
        pointer-events: none;
        z-index: 1;
      }

      /* Image regions */
      .slot {
        position: absolute;
        left: 0;
        right: 0;
        overflow: hidden;
      }
      .slot.top { top: 0; bottom: calc(50% + var(--bar-h) / 2); }
      .slot.bottom { bottom: 0; top: calc(50% + var(--bar-h) / 2); }

      .slot img {
        position: absolute;
        max-width: 80%;
        max-height: 80%;
        width: auto;
        height: auto;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        object-fit: contain;
        user-select: none;
        -webkit-user-drag: none;
      }


      /* Round tappable button on the mid bar, center-left */
      .btn {
        position: absolute;
        width: var(--btn);
        height: var(--btn);
        border-radius: 50%;
        border: var(--border) solid var(--pink);
        background: var(--pink);
        left: 50%; /* centered */
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 4;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        outline: none;
        cursor: pointer;
        box-shadow: 0 10px 24px rgba(0,0,0,0.35), 0 6px 18px rgba(255,46,166,0.35);
        transition: transform 120ms ease-out, box-shadow 120ms ease-out;
      }
      .btn:active { transform: translate(-50%, -50%) scale(0.94); }

      /* Tap animation class toggled on click */
      @keyframes pulse {
        0% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(0.92); }
        100% { transform: translate(-50%, -50%) scale(1); }
      }
      .btn.pulse { animation: pulse 180ms ease-out; }

      /* Shake + zoom effect for active cycling */
      @keyframes rumbleZoom {
        0%   { transform: translate(0, 0) scale(1.00); }
        20%  { transform: translate(-1.2%, 0.8%) scale(1.03); }
        40%  { transform: translate(1.1%, -0.9%) scale(1.05); }
        60%  { transform: translate(-0.8%, -0.6%) scale(1.04); }
        80%  { transform: translate(0.9%, 1.0%) scale(1.06); }
        100% { transform: translate(0, 0) scale(1.00); }
      }
      .fx {
        animation: rumbleZoom 120ms linear infinite;
        will-change: transform;
      }

      /* Enemy HP bar */
      /* Enemy HP container + label */
      .hp { position:absolute; top:6px; left:16px; right:16px; z-index:3; display:flex; align-items:center; gap:10px; }
      .hp__label { color:#ffd400; font:800 clamp(18px,3.6vw,28px)/1.1 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; text-shadow:0 0 10px rgba(255,212,0,.6); min-width:62px; }
      .hp__track {
        position: relative;
        flex: 1 1 auto;
        height: 18px;
        border-radius: 999px;
        background: #0d0d0d;
        border: 3px solid #ffd400;
        overflow: hidden;
        box-shadow: inset 0 0 8px rgba(255,212,0,.25);
      }
      .hp__fill {
        height: 100%;
        width: 100%;
        background: linear-gradient(180deg,#ffe766,#ffd400);
        transition: width 3500ms linear;
      }
      .hp__track.flash { animation: hpflash 500ms ease-in-out 6; }
      @keyframes hpflash {
        0%,100% { box-shadow: 0 0 0 rgba(255,0,0,0); border-color:#ffd400; }
        50%     { box-shadow: 0 0 22px rgba(255,0,0,.95), inset 0 0 12px rgba(255,0,0,.95); border-color:#ff3b3b; }
      }

      /* Rapid red damage numbers */
      .dmg {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        color: #ff3030;
        font: 800 clamp(28px, 6vw, 64px)/1 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
        text-shadow: 0 0 6px rgba(255,0,0,0.85), 0 0 12px rgba(255,0,0,0.55);
        pointer-events: none;
        mix-blend-mode: screen;
        animation: dmgPop 320ms ease-out forwards;
        z-index: 6;
      }
      @keyframes dmgPop {
        0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }
        40%  { opacity: 1; transform: translate(-50%, -65%) scale(1.15); }
        100% { opacity: 0; transform: translate(-50%, -82%) scale(0.95); }
      }

      /* Respect reduced motion */
      @media (prefers-reduced-motion: reduce) {
        .slot.fx { animation: none; }
        .dmg { animation: none; opacity: 1; }
      }

      /* Ensure layout remains clean if shown in landscape */
      @media (orientation: landscape) {
        .mid { --bar-h: clamp(3px, 1.5vh, 10px); }
        .btn { left: 50%; }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="slot top">
        <div class="hp" aria-label="Enemy HP">
          <span class="hp__label">HP 100</span>
          <div class="hp__track"><div class="hp__fill"></div></div>
        </div>
        <div class="sprite enemy-sprite">
        <img src="enemy1.jpg" alt="" draggable="false" />
        </div>
      </div>

      <div class="slot bottom">
        <div class="sprite char-sprite">
        <img src="elf1.jpg" alt="" draggable="false" />
        </div>
      </div>

      <div class="mid"></div>
      <button class="btn" type="button" aria-label="action"></button>
      <div class="frame"></div>
    </div>

    <script>
      'use strict';

      // Mobile Safari viewport height fix
      (function () {
        const root = document.documentElement;
        function setVH() {
          root.style.setProperty('--vh', window.innerHeight * 0.01 + 'px');
        }
        setVH();
        window.addEventListener('resize', setVH, { passive: true });
        window.addEventListener('orientationchange', setVH, { passive: true });
      })();

      // Utilities
      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Spawn rapid damage numbers over a slot for a duration
      function spawnDamageNumbers(slotEl, durationMs, everyMs) {
        if (!slotEl) return Promise.resolve();
        const start = performance.now();
        return new Promise(function(resolve){
          const timer = setInterval(function(){
            const n = document.createElement('span');
            n.className = 'dmg';
            n.textContent = String(randInt(5, 25));
            // Random placement within the slot area using percentages
            // Bias toward center: 30%..70%
            const x = 30 + Math.random() * 40;
            const y = 30 + Math.random() * 40;
            n.style.left = x + '%';
            n.style.top  = y + '%';
            slotEl.appendChild(n);
            // Auto-remove after animation (~320ms)
            setTimeout(function(){ n.remove(); }, 360);
          }, everyMs);

          function stop(){ clearInterval(timer); resolve(); }
          function rafCheck(t){
            if (t - start >= durationMs) stop();
            else requestAnimationFrame(rafCheck);
          }
          requestAnimationFrame(rafCheck);
        });
      }

      // Button tap animation + image cycling sequence
      (function(){
        const btn = document.querySelector('.btn');
        const charImg = document.querySelector('.slot.bottom img');
        const enemyImg = document.querySelector('.slot.top img');
        const hpTrack = document.querySelector('.hp__track');
        const hpFill  = document.querySelector('.hp__fill');
        const hpLabel = document.querySelector('.hp__label');

        const charFrames = ['elf1.jpg','elf2.jpg','elf3.jpg'];
        const enemyFrames = ['enemy1.jpg','enemy2.jpg','enemy3.jpg'];

        // Preload to minimize flicker
        [...charFrames, ...enemyFrames].forEach(function(src){ const i = new Image(); i.src = src; });

        let busy = false;

        function cycleImage(el, frames, ms, intervalMs) {
          return new Promise(function(resolve){
            var idx = 0;
            var animTarget = el.closest('.sprite') || el.closest('.slot');
            if (animTarget) animTarget.classList.add('fx');

            var t0 = performance.now();
            // Set start frame to avoid off-by-one visual pop
            el.src = frames[idx];
            var timer = setInterval(function(){
              idx = (idx + 1) % frames.length;
              el.src = frames[idx];
            }, intervalMs);

            function stop(){
              clearInterval(timer);
              if (animTarget) animTarget.classList.remove('fx');
              resolve();
            }
            function rafCheck(t){
              if (t - t0 >= ms) stop();
              else requestAnimationFrame(rafCheck);
            }
            requestAnimationFrame(rafCheck);
          });
        }

        async function runSequence(){
          if (busy) return;
          busy = true;

          // Button pulse animation retrigger
          btn.classList.remove('pulse');
          void btn.offsetWidth; // reflow
          btn.classList.add('pulse');

          const enemySlot = enemyImg ? enemyImg.closest('.slot') : null;

          // 1) Attacker animates for 2s, then stops
          const elfDuration = 2000;           // 2 seconds
          const slowInterval = 180;           // slower image cycling for both
          await cycleImage(charImg, charFrames, elfDuration, slowInterval);

          // 2) After attacker stops, enemy receives damage and animates
          const enemyDuration = 3000;         // damage window

          // Reset HP bar instantly to 100% before damage sequence
          if (hpFill) {
            hpFill.style.transition = 'none';
            hpFill.style.width = '100%';
            void hpFill.offsetWidth;
          }

          // Start enemy visual reactions
          const enemyP = cycleImage(enemyImg, enemyFrames, enemyDuration, slowInterval);
          const dmgP   = spawnDamageNumbers(enemySlot, enemyDuration, 140);

          // HP flash + depletion tied to enemy damage window
          if (hpTrack && hpFill) {
            hpTrack.classList.add('flash');
            hpFill.style.transition = `width ${enemyDuration}ms linear`;
            requestAnimationFrame(()=>{ hpFill.style.width = '0%'; });
            if (hpLabel) {
              const tStart = performance.now();
              (function step(t){
                const pct = Math.max(0, 1 - (t - tStart)/enemyDuration);
                const val = Math.round(pct * 100);
                hpLabel.textContent = `HP ${val}`;
                if (pct > 0) requestAnimationFrame(step);
              })(performance.now());
            }
            setTimeout(()=> hpTrack.classList.remove('flash'), enemyDuration);
          }

          await Promise.all([enemyP, dmgP]);

          busy = false;
        }

        if (btn) {
          btn.addEventListener('click', runSequence, { passive: true });
        }

        // --- Basic non-visual tests (console only) ---
        (function runTests(){
          // Use tiny data-URL images so tests do not depend on project assets
          var px1 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAusB9p6J2x0AAAAASUVORK5CYII=';
          var px2 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/w8AApEB1wP2y+0AAAAASUVORK5CYII=';
          var px3 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8//8AAoMB4pKxY0QAAAAASUVORK5CYII=';

          var dummy = new Image();
          dummy.src = px1;

          var start = performance.now();
          var p = cycleImage(dummy, [px1, px2, px3], 200, 80);
          console.assert(typeof p === 'object' && typeof p.then === 'function', 'cycleImage returns a Promise');
          p.then(function(){
            var elapsed = performance.now() - start;
            console.assert(elapsed >= 180, 'cycleImage duration should be at least ~180ms');
            console.assert([px1, px2, px3].indexOf(dummy.src) !== -1, 'dummy src should be set to one of the frames');
          }).catch(function(e){
            console.error('Test error:', e);
          });
        })();
        // --- End tests ---
      })();
    </script>
  </body>
</html>
