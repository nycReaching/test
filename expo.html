<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Isometric Voxel UI</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use the Inter font */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* This container provides the 3D perspective */
        #game-world-wrapper {
            perspective: 1000px;
            /* Added for touch controls */
            touch-action: none; 
        }

        /* This container is rotated to create the isometric view */
        #iso-world {
            transform-style: preserve-3d;
            transform: rotateX(60deg) rotateZ(45deg);
            /* Add transition for smooth zooming */
            transition: transform 0.1s ease-out;
        }

        /* The "ground" plane container */
        #game-area {
            /* New grid size: 20 tiles * 20px/tile = 400px */
            width: 400px;
            height: 400px;
            /* Removed background, it's now a container */
            position: absolute;
            top: 50%;
            left: 50%;
            /* Center the plane */
            transform: translate(-50%, -50%);
            transform-style: preserve-3d; /* So tile Z-transforms work */
        }

        /* New Voxel Tile styling */
        .voxel-tile {
            width: 20px;
            height: 20px;
            position: absolute;
            box-sizing: border-box;
            /* Base emerald-400 */
            background: #34d399; 
            /* Simple 3D effect using borders, scales with height */
            /* We will set this in JS */
        }

        /* The player icon, styled to look like a simple voxel */
        #player {
            width: 20px;
            height: 20px;
            background: #ef4444; /* red-500 */
            position: absolute;
            top: 50%;
            left: 50%;
            /* Start at 0,0 (center of the area) */
            /* We use calc() to combine centering with JS-driven translation */
            /* translateZ will be updated by JS */
            transform: translate(calc(-50% + 0px), calc(-50% + 0px)) translateZ(0px);
            /* Make transition slightly slower to see Z changes */
            transition: transform 0.05s linear;
            
            /* Simple 3D effect using borders */
            border-bottom: 4px solid #b91c1c; /* red-800 */
            border-right: 2px solid #dc2626; /* red-600 */
            box-sizing: border-box; /* Include border in width/height */
            z-index: 10; /* Ensure player is "on top" */
        }

        /* Base styling for control buttons */
        .control-btn {
            background-color: #4b5563; /* gray-600 */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.1s;
            /* Disable user selection and tap highlights for a native feel */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        /* Active state for a responsive feel */
        .control-btn:active {
            background-color: #6b7280; /* gray-500 */
        }

        /* New center button */
        #btn-action {
            background-color: #3b82f6; /* blue-500 */
        }
        #btn-action:active {
            background-color: #60a5fa; /* blue-400 */
        }
    </style>
</head>
<body class="bg-gray-800 text-white overflow-hidden">

    <!-- Main game container, laid out for portrait mobile -->
    <div id="game-container" class="flex flex-col h-screen w-screen">

        <!-- Header -->
        <header class="w-full text-center p-4 bg-gray-900 shadow-lg z-10">
            <h1 class="text-xl font-bold">Iso-Voxel World</h1>
        </header>

        <!-- Game World Wrapper: This centers the iso-world and applies perspective -->
        <main id="game-world-wrapper" class="flex-grow w-full flex items-center justify-center overflow-hidden">
            
            <!-- Isometric World: This container is rotated -->
            <div id="iso-world" class="relative">
                
                <!-- Game Area: The ground plane -->
                <div id="game-area"></div>
                
                <!-- Player Icon -->
                <div id="player"></div>

            </div>
        </main>

        <!-- UI Controls -->
        <footer id="controls" class="w-full p-6 bg-gray-900 shadow-inner z-10">
            <div class="flex justify-center">
                <!-- D-Pad layout using a simple grid -->
                <div class="grid grid-cols-3 gap-1 w-36 text-2xl font-bold"> <!-- Reduced size and text -->
                    <!-- Row 1 -->
                    <div></div> <!-- Top-left empty -->
                    <button id="btn-up" class="control-btn w-full h-12 rounded-t-lg">&uarr;</button> <!-- Reduced size -->
                    <div></div> <!-- Top-right empty -->

                    <!-- Row 2 -->
                    <button id="btn-left" class="control-btn h-12 rounded-l-lg">&larr;</button> <!-- Reduced size -->
                    
                    <!-- New Center Button -->
                    <button id="btn-action" class="control-btn h-12 rounded-full">A</button> 
                    
                    <button id="btn-right" class="control-btn h-12 rounded-r-lg">&rarr;</button> <!-- Reduced size -->

                    <!-- Row 3 -->
                    <div></div> <!-- Bottom-left empty -->
                    <button id="btn-down" class="control-btn w-full h-12 rounded-b-lg">&darr;</button> <!-- Reduced size -->
                    <div></div> <!-- Bottom-right empty -->
                </div>
            </div>
        </footer>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const player = document.getElementById('player');
            const gameArea = document.getElementById('game-area');
            const isoWorld = document.getElementById('iso-world');
            const gameWorldWrapper = document.getElementById('game-world-wrapper');
            const btnUp = document.getElementById('btn-up');
            const btnDown = document.getElementById('btn-down');
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            const btnAction = document.getElementById('btn-action');

            // --- Game World Constants ---
            const GRID_SIZE = 20; // 20x20 grid
            const TILE_SIZE = 20; // 20px per tile
            const HEIGHT_UNIT = 8; // Each height level is 8px
            
            const AREA_WIDTH = GRID_SIZE * TILE_SIZE;
            const AREA_HEIGHT = GRID_SIZE * TILE_SIZE;
            
            let heightMap = [];

            // --- Player Constants ---
            const MOVE_SPEED = 5; // Pixels to move per step
            const PLAYER_WIDTH = 20;
            const PLAYER_HEIGHT = 20;

            // Calculate movement boundaries
            const minX = -AREA_WIDTH / 2 + PLAYER_WIDTH / 2;
            const maxX = AREA_WIDTH / 2 - PLAYER_WIDTH / 2;
            const minY = -AREA_HEIGHT / 2 + PLAYER_HEIGHT / 2;
            const maxY = AREA_HEIGHT / 2 - PLAYER_HEIGHT / 2;

            // Player's state (position is relative to the center of the game area)
            const playerState = {
                x: 0,
                y: 0,
                z: 0,
                // Track which buttons are held down
                holding: { up: false, down: false, left: false, right: false }
            };

            // --- Zoom State ---
            let currentScale = 1.0;
            let initialPinchDistance = 0;
            const maxScale = 2.5;
            const minScale = 0.5;

            // --- World Generation ---
            function createWorld() {
                // Simple noise function for terrain
                const a = Math.random() * 10;
                const b = Math.random() * 10;
                
                for (let y = 0; y < GRID_SIZE; y++) {
                    heightMap[y] = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        // Generate some simple hilly terrain
                        const noiseVal = Math.sin(y / 5 + a) + Math.cos(x / 5 + b); // Simple wave noise
                        let height = 0;
                        if (noiseVal > 0.8) {
                            height = 2; // Hilltop
                        } else if (noiseVal > 0) {
                            height = 1; // Slope
                        } else if (noiseVal < -1.2) {
                            height = -1; // Valley
                        } else {
                            height = 0; // Ground
                        }
                        heightMap[y][x] = height;

                        const tile = document.createElement('div');
                        tile.className = 'voxel-tile';
                        
                        const z = height * HEIGHT_UNIT;
                        const posX = x * TILE_SIZE;
                        const posY = y * TILE_SIZE;

                        // Style the tile based on height
                        const sideThickness = Math.max(1, Math.abs(z / 2) + 4);
                        
                        let bgColor, bdrColor, sideColor;

                        if (height === -1) { // Valley (water)
                            bgColor = '#3b82f6'; // blue-500
                            bdrColor = '#1d4ed8'; // blue-700
                            sideColor = '#2563eb'; // blue-600
                        } else if (height === 0) { // Ground
                            bgColor = '#10b981'; // emerald-600
                            bdrColor = '#047857'; // emerald-700
                            sideColor = '#059669'; // emerald-600
                        } else if (height === 1) { // Slope
                            bgColor = '#34d399'; // emerald-400
                            bdrColor = '#065f46'; // emerald-800
                            sideColor = '#047857'; // emerald-700
                        } else { // Hilltop (snow)
                            bgColor = '#f9fafb'; // gray-50
                            bdrColor = '#9ca3af'; // gray-400
                            sideColor = '#d1d5db'; // gray-300
                        }

                        tile.style.left = `${posX}px`;
                        tile.style.top = `${posY}px`;
                        tile.style.transform = `translateZ(${z}px)`;
                        tile.style.background = bgColor;
                        tile.style.borderBottom = `${sideThickness}px solid ${bdrColor}`;
                        tile.style.borderRight = `${sideThickness / 2}px solid ${sideColor}`;

                        gameArea.appendChild(tile);
                    }
                }
            }

            // Updates the player's CSS transform based on its state
            function updatePlayerPosition() {
                // Map player's centered (x,y) to game-area's (0, 400)
                const areaX = playerState.x + AREA_WIDTH / 2;
                const areaY = playerState.y + AREA_HEIGHT / 2;

                // Map game-area (x,y) to grid (0, 19)
                const gridX = Math.floor(areaX / TILE_SIZE);
                const gridY = Math.floor(areaY / TILE_SIZE);
                
                // Clamp to grid boundaries to prevent errors
                const safeGridX = Math.max(0, Math.min(GRID_SIZE - 1, gridX));
                const safeGridY = Math.max(0, Math.min(GRID_SIZE - 1, gridY));

                // Get the height of the tile the player is on
                playerState.z = heightMap[safeGridY][safeGridX] * HEIGHT_UNIT;

                // By moving the player with translate(x, y) *inside* the
                // rotated #iso-world, the movement appears to be
                // along the isometric axes.
                player.style.transform = `translate(calc(-50% + ${playerState.x}px), calc(-50% + ${playerState.y}px)) translateZ(${playerState.z}px)`;
            }

            // Updates the world's scale/rotation
            function updateWorldTransform() {
                isoWorld.style.transform = `rotateX(60deg) rotateZ(45deg) scale(${currentScale})`;
            }

            // Game loop to handle continuous movement
            function gameLoop() {
                let dx = 0;
                let dy = 0;

                if (playerState.holding.up) dy -= MOVE_SPEED;
                if (playerState.holding.down) dy += MOVE_SPEED;
                if (playerState.holding.left) dx -= MOVE_SPEED;
                if (playerState.holding.right) dx += MOVE_SPEED;

                if (dx !== 0 || dy !== 0) {
                    // Calculate new position
                    const newX = playerState.x + dx;
                    const newY = playerState.y + dy;

                    // Clamp position within boundaries
                    playerState.x = Math.max(minX, Math.min(maxX, newX));
                    playerState.y = Math.max(minY, Math.min(maxY, newY));

                    updatePlayerPosition();
                }

                // Continue the loop
                requestAnimationFrame(gameLoop);
            }

            // --- Event Listeners ---

            // We use mousedown/mouseup and touchstart/touchend to allow
            // for "holding" the button down, which is better for games.

            function createButtonListeners(button, direction) {
                // Set 'holding' state to true
                function onPress(e) {
                    e.preventDefault(); // Prevent scrolling/zooming
                    playerState.holding[direction] = true;
                }

                // Set 'holding' state to false
                function onRelease(e) {
                    e.preventDefault();
                    playerState.holding[direction] = false;
                }

                // Mouse events
                button.addEventListener('mousedown', onPress);
                button.addEventListener('mouseup', onRelease);
                button.addEventListener('mouseleave', onRelease); // Stop if mouse leaves button

                // Touch events
                button.addEventListener('touchstart', onPress, { passive: false });
                button.addEventListener('touchend', onRelease, { passive: false });
                button.addEventListener('touchcancel', onRelease, { passive: false });
            }

            createButtonListeners(btnUp, 'up');
            createButtonListeners(btnDown, 'down');
            createButtonListeners(btnLeft, 'left');
            createButtonListeners(btnRight, 'right');

            // --- New listener for the action button ---
            // This just logs to the console for now to show it's "tappable"
            function onActionPress(e) {
                e.preventDefault();
                console.log('Action Button Pressed!');
                // You could add a 'jump' or 'action' state here
            }
            
            btnAction.addEventListener('mousedown', onActionPress);
            btnAction.addEventListener('touchstart', onActionPress, { passive: false });

            // --- Pinch-to-Zoom Listeners ---
            
            // Helper to get distance between two touches
            function getPinchDistance(touches) {
                const touch1 = touches[0];
                const touch2 = touches[1];
                return Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            }

            function handleTouchStart(e) {
                if (e.touches.length === 2) {
                    e.preventDefault(); // Prevent page zoom
                    initialPinchDistance = getPinchDistance(e.touches);
                }
            }

            function handleTouchMove(e) {
                if (e.touches.length === 2) {
                    e.preventDefault(); // Prevent page scroll/zoom
                    
                    const newDistance = getPinchDistance(e.touches);
                    // Get the difference in distance
                    const deltaDistance = newDistance - initialPinchDistance;

                    // Update scale, scaling by a small factor
                    currentScale += deltaDistance * 0.005; 
                    
                    // Clamp the scale
                    currentScale = Math.max(minScale, Math.min(maxScale, currentScale));

                    // Update the world transform
                    updateWorldTransform();

                    // Reset initial distance for next frame
                    initialPinchDistance = newDistance;
                }
            }

            function handleTouchEnd(e) {
                // Reset pinch distance when fingers are lifted
                if (e.touches.length < 2) {
                    initialPinchDistance = 0;
                }
            }

            gameWorldWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
            gameWorldWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
            gameWorldWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
            gameWorldWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });


            // Prevent context menu on long-press (common on mobile)
            window.addEventListener('contextmenu', (e) => e.preventDefault());

            // --- Start the game ---
            createWorld();
            updatePlayerPosition(); // Set initial position
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
