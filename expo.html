<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Isometric Grid UI</title>
  <style>
    :root {
      /* JS will keep this updated as an extra fallback */
      --vh: 1vh;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; margin: 0; background: #000; color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    /* Use the most reliable viewport units on mobile while supporting older engines */
    #app {
      position: fixed;
      inset: 0;
      /* Prefer small viewport units that ignore browser UI expansion */
      height: 100svh;
      /* Fallbacks */
      height: calc(var(--vh) * 100);
      background: #000;
      display: grid;
      grid-template-rows: 1fr auto;
    }

    #stage {
      position: relative;
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    canvas { display: block; width: 100%; height: 100%; touch-action: none; }

    /* Controls */
    .controls {
      position: relative;
      display: grid;
      grid-template-areas:
        ".  up   ."
        "left mid right"
        ". down .";
      grid-template-columns: 64px 64px 64px;
      grid-template-rows: 64px 64px 64px;
      justify-content: center;
      gap: 10px;
      padding: 10px;
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      user-select: none;
    }

    .btn {
      width: 64px; height: 64px; border-radius: 18px; border: 1px solid #444;
      background: #111; color: #fff; font-size: 18px; display: grid; place-items: center;
      box-shadow: 0 2px 8px rgba(0,0,0,.6) inset, 0 4px 16px rgba(0,0,0,.4);
      transition: transform .05s ease, background-color .1s ease, border-color .1s ease;
    }
    .btn:active { transform: translateY(1px) scale(0.98); background: #181818; border-color: #555; }
    .btn:focus-visible { outline: 2px solid #888; outline-offset: 2px; }

    .up    { grid-area: up; }
    .down  { grid-area: down; }
    .left  { grid-area: left; }
    .right { grid-area: right; }
    .mid   { grid-area: mid; opacity: .5; }

    .legend { text-align: center; font-size: 12px; opacity: .7; margin-top: 4px; }
  </style>
</head>
<body>
  <div id="app" role="application" aria-label="Isometric grid with movable cube">
    <div id="stage">
      <canvas id="game" aria-hidden="true"></canvas>
    </div>

    <div class="controls" aria-label="Controls">
      <button class="btn up"    data-move="0,-1" aria-label="Move up">▲</button>
      <button class="btn left"  data-move="-1,0" aria-label="Move left">◄</button>
      <div    class="btn mid"   aria-hidden="true">■</div>
      <button class="btn right" data-move="1,0" aria-label="Move right">►</button>
      <button class="btn down"  data-move="0,1" aria-label="Move down">▼</button>
      <div class="legend">Tap arrows or use arrow keys</div>
    </div>
  </div>

  <script>
    // Viewport height fallback for older mobile browsers
    function setVH() {
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    setVH();
    window.addEventListener('resize', setVH);
    window.addEventListener('orientationchange', () => setTimeout(setVH, 100));

    // Canvas setup with HiDPI scaling
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

    function fitCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
      draw();
    }

    // Grid configuration
    const grid = { cols: 10, rows: 10, tileW: 64, tileH: 32 };
    const cube = { x: 5, y: 5 };

    // Screen coordinate from grid coordinate (isometric)
    function iso(x, y) {
      const sx = (x - y) * (grid.tileW / 2);
      const sy = (x + y) * (grid.tileH / 2);
      return { x: sx, y: sy };
    }

    function centerForGrid() {
      // Center the grid in the available canvas
      const totalW = (grid.cols + grid.rows) * (grid.tileW / 2);
      const totalH = (grid.cols + grid.rows) * (grid.tileH / 2);
      const rect = canvas.getBoundingClientRect();
      const cx = rect.width / 2;
      const cy = rect.height / 2 - grid.tileH; // small lift for cube
      return { cx, cy, totalW, totalH };
    }

    function drawGrid() {
      const { cx, cy } = centerForGrid();
      ctx.save();
      ctx.translate(cx, cy);

      // Grid lines
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';

      // Diagonals one way (constant x+y)
      for (let k = 0; k <= grid.cols + grid.rows; k++) {
        const start = iso(Math.max(0, k - grid.rows), Math.min(k, grid.rows));
        const end   = iso(Math.min(k, grid.cols), Math.max(0, k - grid.cols));
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
      }

      // Diagonals the other way (constant x-y)
      for (let k = -grid.rows; k <= grid.cols; k++) {
        const start = iso(Math.max(0, k), 0 - Math.min(0, k));
        const end   = iso(Math.max(0, k) + Math.min(grid.rows, grid.cols - k), Math.min(grid.rows, grid.cols - k));
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
      }

      // Outline
      const corners = [iso(0,0), iso(grid.cols,0), iso(grid.cols,grid.rows), iso(0,grid.rows)];
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.moveTo(corners[0].x, corners[0].y);
      for (let i=1;i<corners.length;i++) ctx.lineTo(corners[i].x, corners[i].y);
      ctx.closePath();
      ctx.stroke();

      ctx.restore();
    }

    function drawCube() {
      const { cx, cy } = centerForGrid();
      const p = iso(cube.x, cube.y);
      const baseX = cx + p.x;
      const baseY = cy + p.y;

      const w = grid.tileW / 2;
      const h = grid.tileH / 2;
      const height = grid.tileH; // cube vertical height in pixels

      // Top face
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - height);
      ctx.lineTo(baseX + w, baseY - height + h);
      ctx.lineTo(baseX, baseY - height + 2*h);
      ctx.lineTo(baseX - w, baseY - height + h);
      ctx.closePath();
      ctx.fillStyle = '#9ad5ff';
      ctx.fill();

      // Right face
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - height + 2*h);
      ctx.lineTo(baseX + w, baseY - height + h);
      ctx.lineTo(baseX + w, baseY + h);
      ctx.lineTo(baseX, baseY + 2*h);
      ctx.closePath();
      ctx.fillStyle = '#6aa7d6';
      ctx.fill();

      // Left face
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - height + 2*h);
      ctx.lineTo(baseX - w, baseY - height + h);
      ctx.lineTo(baseX - w, baseY + h);
      ctx.lineTo(baseX, baseY + 2*h);
      ctx.closePath();
      ctx.fillStyle = '#4f88b5';
      ctx.fill();

      // Base diamond highlight
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX + w, baseY + h);
      ctx.lineTo(baseX, baseY + 2*h);
      ctx.lineTo(baseX - w, baseY + h);
      ctx.closePath();
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.stroke();
    }

    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function draw() {
      clear();
      drawGrid();
      drawCube();
    }

    function move(dx, dy) {
      const nx = Math.max(0, Math.min(grid.cols, cube.x + dx));
      const ny = Math.max(0, Math.min(grid.rows, cube.y + dy));
      cube.x = nx; cube.y = ny;
      draw();
    }

    // Button controls
    document.querySelectorAll('.btn[data-move]').forEach(btn => {
      const [dx, dy] = btn.dataset.move.split(',').map(Number);
      const press = () => move(dx, dy);
      btn.addEventListener('click', press);
      btn.addEventListener('touchstart', e => { e.preventDefault(); press(); }, { passive: false });
    });

    // Keyboard controls for convenience
    window.addEventListener('keydown', e => {
      switch (e.key) {
        case 'ArrowUp':    move(0,-1); break;
        case 'ArrowDown':  move(0, 1); break;
        case 'ArrowLeft':  move(-1,0); break;
        case 'ArrowRight': move(1, 0); break;
      }
    });

    // Resize handling and initial draw
    const ro = new ResizeObserver(fitCanvas);
    ro.observe(document.getElementById('stage'));
    fitCanvas();
  </script>
</body>
</html>
