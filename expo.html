<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>System Monitor UI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            touch-action: none;
        }

        body {
            background-color: #0a0a0a;
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .top-panel {
            height: 25%;
            background: 
                radial-gradient(ellipse at 50% -20%, rgba(0, 255, 200, 0.1) 0%, transparent 60%),
                linear-gradient(180deg, #1a1a2e 0%, #121212 100%);
            border-bottom: 3px solid #00ffcc;
            box-shadow: 0 0 20px rgba(0, 255, 200, 0.2);
            display: flex;
            flex-direction: column;
            padding: 12px;
            position: relative;
            overflow: hidden;
        }

        .top-panel::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 3px,
                rgba(0, 255, 200, 0.05) 3px,
                rgba(0, 255, 200, 0.05) 6px
            );
            pointer-events: none;
            animation: scan 8s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(0); }
            100% { transform: translateY(6px); }
        }

        .data-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: clamp(16px, 4.5vw, 24px);
            position: relative;
            z-index: 2;
        }

        .data-label {
            color: #00ffcc;
            text-shadow: 0 0 8px rgba(0, 255, 204, 0.4);
        }

        .data-value {
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.4);
            transition: all 0.3s ease;
        }

        .data-value.pulse {
            transform: scale(1.1);
            color: #ff00aa;
            text-shadow: 0 0 12px rgba(255, 0, 170, 0.6);
        }

        .chart-container {
            flex: 1;
            position: relative;
            min-height: 50px;
            z-index: 1;
        }

        #dataChart {
            width: 100%;
            height: 100%;
            display: block;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin-top: 8px;
            position: relative;
            z-index: 2;
        }

        .status-item {
            font-size: clamp(11px, 3vw, 16px);
            text-align: center;
            background: rgba(0, 255, 200, 0.05);
            border: 1px solid rgba(0, 255, 200, 0.2);
            border-radius: 4px;
            padding: 4px 0;
            transition: all 0.3s ease;
        }

        .status-item.active {
            background: rgba(255, 0, 170, 0.2);
            border-color: #ff00aa;
            box-shadow: 0 0 8px rgba(255, 0, 170, 0.4);
        }

        .status-label {
            color: #888;
            font-size: 0.7em;
            margin-bottom: 2px;
        }

        .status-value {
            color: #ffdd00;
            font-weight: bold;
        }

        .bottom-panel {
            height: 75%;
            background-color: #0a0a0a;
            position: relative;
        }

        .alert-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff0044;
            opacity: 0;
            animation: alertPulse 2s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { opacity: 0; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.5); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="top-panel">
            <div class="alert-indicator" id="alert"></div>
            <div class="data-header">
                <span class="data-label">NEURAL CORE v2.7</span>
                <span class="data-value" id="mainMetric">127.43</span>
            </div>
            <div class="chart-container">
                <canvas id="dataChart"></canvas>
            </div>
            <div class="status-grid">
                <div class="status-item" id="item0">
                    <div class="status-label">LAYER 1</div>
                    <div class="status-value" id="stat1">98.2%</div>
                </div>
                <div class="status-item" id="item1">
                    <div class="status-label">LAYER 2</div>
                    <div class="status-value" id="stat2">72.8</div>
                </div>
                <div class="status-item" id="item2">
                    <div class="status-label">CYCLE</div>
                    <div class="status-value" id="stat3">142ms</div>
                </div>
                <div class="status-item" id="item3">
                    <div class="status-label">STATUS</div>
                    <div class="status-value" id="stat4">OK</div>
                </div>
            </div>
        </div>
        <div class="bottom-panel">
            <!-- Game content -->
        </div>
    </div>

    <script>
        const canvas = document.getElementById('dataChart');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const dataPoints = [];
        const secondaryPoints = [];
        const maxPoints = 80;
        
        for (let i = 0; i < maxPoints; i++) {
            dataPoints.push(Math.random() * 40 + 110);
            secondaryPoints.push(Math.random() * 30 + 90);
        }

        // Particle system
        const particles = [];
        
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.8;
                this.vy = -Math.random() * 1.5 - 0.5;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 2 + 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.015;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life * 0.6;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.restore();
            }
        }

        let lastUpdate = 0;
        let waveOffset = 0;
        
        function animateChart(timestamp) {
            waveOffset += 0.05;
            
            // Update data every 800ms
            if (timestamp - lastUpdate > 800) {
                const lastValue = dataPoints[dataPoints.length - 1];
                const change = Math.sin(waveOffset) * 2 + (Math.random() - 0.5) * 3;
                let newValue = Math.max(100, Math.min(150, lastValue + change));
                dataPoints.push(newValue);
                if (dataPoints.length > maxPoints) dataPoints.shift();

                // Secondary line
                secondaryPoints.push(newValue - 15 + Math.random() * 10);
                if (secondaryPoints.length > maxPoints) secondaryPoints.shift();

                // Spawn particles
                if (Math.random() > 0.7) {
                    const width = canvas.offsetWidth;
                    const height = canvas.offsetHeight;
                    const x = width - 10;
                    const y = height - ((newValue - 100) / 50) * height;
                    particles.push(new Particle(x, y, '#00ffcc'));
                }

                lastUpdate = timestamp;
            }

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            ctx.clearRect(0, 0, width, height);

            // Animated grid
            const gridOffset = (timestamp * 0.01) % 20;
            ctx.strokeStyle = 'rgba(0, 255, 204, 0.12)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const y = (height / 5) * i + gridOffset;
                if (y < height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }

            // Secondary line (background)
            ctx.strokeStyle = 'rgba(255, 0, 170, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            secondaryPoints.forEach((value, index) => {
                const x = (width / maxPoints) * index;
                const y = height - ((value - 90) / 60) * height;
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Primary line with glow
            ctx.strokeStyle = '#00ffcc';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ffcc';
            ctx.beginPath();
            
            dataPoints.forEach((value, index) => {
                const x = (width / maxPoints) * index;
                const waveY = Math.sin(waveOffset + index * 0.1) * 2;
                const y = height - ((value - 100) / 50) * height + waveY;
                
                if (index === 0) ctx.moveTo(x, y);
                else ctx.quadraticCurveTo(x - (width / maxPoints) / 2, y, x, y);
            });
            
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Fill area
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(0, 255, 204, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 255, 204, 0)');
            
            ctx.fillStyle = gradient;
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();

            // Update and draw particles
            particles.forEach((p, i) => {
                p.update();
                p.draw(ctx);
                if (p.life <= 0 || p.y < 0) particles.splice(i, 1);
            });

            requestAnimationFrame(animateChart);
        }

        animateChart();

        // Update every 4 seconds
        function updateMetrics() {
            const currentValue = parseFloat(document.getElementById('mainMetric').textContent);
            const change = (Math.random() - 0.5) * 1.5;
            const newValue = currentValue + change;
            document.getElementById('mainMetric').textContent = newValue.toFixed(2);
            
            // Pulse effect on significant change
            const metricEl = document.getElementById('mainMetric');
            if (Math.abs(change) > 0.5) {
                metricEl.classList.add('pulse');
                setTimeout(() => metricEl.classList.remove('pulse'), 300);
            }

            // Update stats
            const stat1Value = 96 + Math.random() * 3;
            document.getElementById('stat1').textContent = stat1Value.toFixed(1) + '%';
            
            const stat2Value = 70 + Math.random() * 10;
            document.getElementById('stat2').textContent = stat2Value.toFixed(1);
            
            const stat3Value = 140 + Math.random() * 20;
            document.getElementById('stat3').textContent = stat3Value.toFixed(0) + 'ms';

            // Random alert
            const alert = document.getElementById('alert');
            if (Math.random() > 0.97) {
                alert.style.opacity = '1';
                document.getElementById('stat4').textContent = 'SYNC';
                document.getElementById('stat4').style.color = '#ff00aa';
                setTimeout(() => {
                    alert.style.opacity = '0';
                    document.getElementById('stat4').textContent = 'OK';
                    document.getElementById('stat4').style.color = '#ffdd00';
                }, 1500);
            }

            // Random grid item flash
            const randItem = Math.floor(Math.random() * 4);
            const item = document.getElementById(`item${randItem}`);
            item.classList.add('active');
            setTimeout(() => item.classList.remove('active'), 200);
        }

        setInterval(updateMetrics, 4000);

        // Prevent scrolling
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        
        if (screen.orientation?.lock) {
            screen.orientation.lock('portrait').catch(() => {});
        }
    </script>
</body>
</html>
