<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Trader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on mobile while dragging */
        }
        .emoji {
            position: absolute;
            font-size: 2.5rem; /* 40px */
            cursor: grab;
            user-select: none;
            text-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.1s ease-out;
        }
        .emoji.dragging {
            cursor: grabbing;
            transform: scale(1.2);
            z-index: 1000;
        }
        .drop-zone {
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .drop-zone.over {
            transform: scale(1.05);
        }
        #keep-zone.over {
            background-color: #3b82f6; /* blue-500 */
        }
        #sell-zone.over {
             background-color: #22c55e; /* green-500 */
        }

        /* Score animation */
        .score-popup {
            position: absolute;
            animation: floatUp 1.5s ease-out forwards;
            font-weight: bold;
            font-size: 1.25rem;
            pointer-events: none;
            z-index: 2000; /* Ensure it's on top */
        }

        @keyframes floatUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-60px);
            }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100">

    <div id="game-container" class="w-full h-full bg-white dark:bg-gray-800 shadow-2xl relative flex flex-col">

        <!-- Top UI Bar -->
        <div class="flex-shrink-0 flex justify-between items-center p-4 bg-gray-50 dark:bg-gray-700/50 border-b border-gray-200 dark:border-gray-700 z-10">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800 dark:text-white">Emoji Trader</h1>
            <div class="flex space-x-4 md:space-x-6 text-center">
                <div>
                    <span class="text-sm font-semibold text-gray-500 dark:text-gray-400">Score</span>
                    <p id="score" class="text-lg md:text-2xl font-bold text-blue-600 dark:text-blue-400">0</p>
                </div>
                <div>
                    <span class="text-sm font-semibold text-gray-500 dark:text-gray-400">Emojis</span>
                    <p id="emoji-counter" class="text-lg md:text-2xl font-bold text-gray-700 dark:text-gray-300">0 / 100</p>
                </div>
            </div>
        </div>

        <!-- Play Area, contains the emoji field and the drop zones -->
        <div id="play-area" class="flex-grow flex flex-col relative">
            <!-- Emoji Field: where emojis drift -->
            <div id="emoji-field" class="flex-grow relative">
                <!-- Emojis will be dynamically added here -->
            </div>
            
            <!-- Drop Zones -->
            <div class="grid grid-cols-2 gap-0">
                <div id="keep-zone" class="drop-zone bg-blue-400 dark:bg-blue-600 text-white text-center py-6">
                    <h2 class="text-2xl font-bold">KEEP</h2>
                    <p class="text-sm opacity-80">Drag practical items here</p>
                </div>
                <div id="sell-zone" class="drop-zone bg-green-400 dark:bg-green-500 text-white text-center py-6">
                    <h2 class="text-2xl font-bold">SELL</h2>
                    <p class="text-sm opacity-80">Drag valuable items here</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-20">
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-8 text-center max-w-sm w-full">
            <h2 class="text-3xl font-bold mb-2 text-gray-800 dark:text-white">Game Over!</h2>
            <p class="text-gray-600 dark:text-gray-300 mb-4">You finished with a final score of:</p>
            <p id="final-score" class="text-5xl font-bold text-blue-600 dark:text-blue-400 mb-6">0</p>
            <button id="restart-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg w-full text-lg transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>


    <script>
        // --- Element References ---
        const playArea = document.getElementById('play-area');
        const emojiField = document.getElementById('emoji-field');
        const scoreEl = document.getElementById('score');
        const emojiCounterEl = document.getElementById('emoji-counter');
        const keepZoneEl = document.getElementById('keep-zone');
        const sellZoneEl = document.getElementById('sell-zone');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreEl = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // --- Game Configuration ---
        const MAX_EMOJIS = 100;
        const EMOJI_SPAWN_INTERVAL = 1200; // ms

        const EMOJIS = [
            // Practical (good for 'Keep')
            { char: 'ðŸ”¨', type: 'practical', value: 10 }, { char: 'ðŸ”§', type: 'practical', value: 10 },
            { char: 'ï¿½', type: 'practical', value: 8 }, { char: 'ðŸž', type: 'practical', value: 8 },
            { char: 'ðŸ‘•', type: 'practical', value: 6 }, { char: 'ðŸª‘', type: 'practical', value: 6 },
            { char: 'ðŸš—', type: 'practical', value: 15 }, { char: 'ðŸ’»', type: 'practical', value: 15 },
            { char: 'ðŸ“š', type: 'practical', value: 7 }, { char: 'ðŸ’¡', type: 'practical', value: 9 },

            // Valuable (good for 'Sell')
            { char: 'ðŸ’Ž', type: 'valuable', value: 20 }, { char: 'ðŸ’°', type: 'valuable', value: 18 },
            { char: 'ðŸ‘‘', type: 'valuable', value: 16 }, { char: 'ðŸ’', type: 'valuable', value: 14 },
            { char: 'ðŸ–¼ï¸', type: 'valuable', value: 12 }, { char: 'ðŸº', type: 'valuable', value: 12 },
            { char: 'ðŸ“ˆ', type: 'valuable', value: 10 }, { char: 'ðŸ†', type: 'valuable', value: 15 },
            { char: 'ðŸ”‘', type: 'valuable', value: 8 }, { char: 'âœ¨', type: 'valuable', value: 7 },
            
            // Neutral
            { char: 'ðŸ˜Š', type: 'neutral', value: 2 }, { char: 'ðŸ‘', type: 'neutral', value: 2 },
            { char: 'â¤ï¸', type: 'neutral', value: 2 }, { char: 'ðŸŽˆ', type: 'neutral', value: 2 },
            { char: 'â­', type: 'neutral', value: 2 }, { char: 'â“', type: 'neutral', value: 1 },
            { char: 'ðŸ¤”', type: 'neutral', value: 1 },
        ];

        // --- Game State ---
        let score = 0;
        let emojiCount = 0;
        let activeEmojis = [];
        let emojiSpawner;
        let animationFrameId;

        // --- Dragging State ---
        let draggedEmoji = null;
        let offsetX = 0;
        let offsetY = 0;

        function startGame() {
            // Reset state
            score = 0;
            emojiCount = 0;
            activeEmojis = [];
            emojiField.innerHTML = ''; // Clear only the emoji field
            updateUI();
            gameOverModal.classList.add('hidden');

            // Clear any lingering intervals or animation frames
            if (emojiSpawner) clearInterval(emojiSpawner);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            // Start spawning emojis
            emojiSpawner = setInterval(spawnEmoji, EMOJI_SPAWN_INTERVAL);
            
            // Start animation loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function spawnEmoji() {
            // Defensive check: if the game area isn't rendered, wait for the next tick.
            const emojiFieldRect = emojiField.getBoundingClientRect();
            if (emojiFieldRect.width === 0 || emojiFieldRect.height === 0) {
                return;
            }

            const emojiData = EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
            const emojiEl = document.createElement('div');
            emojiEl.classList.add('emoji');
            emojiEl.textContent = emojiData.char;
            
            // Emojis spawn in the center of the emojiField
            const x = emojiFieldRect.width / 2;
            const y = emojiFieldRect.height / 2;

            const emojiState = {
                el: emojiEl,
                data: emojiData,
                x: x,
                y: y,
                dx: (Math.random() - 0.5) * 2, // Speed between -1 and 1
                dy: (Math.random() - 0.5) * 2
            };
            
            emojiEl.style.left = `${x}px`;
            emojiEl.style.top = `${y}px`;

            activeEmojis.push(emojiState);
            emojiField.appendChild(emojiEl);
            
            // Add drag listeners
            emojiEl.addEventListener('mousedown', startDrag);
            emojiEl.addEventListener('touchstart', startDrag, { passive: false });
        }
        
        function gameLoop() {
            // End condition is checked here
            if (emojiCount >= MAX_EMOJIS && activeEmojis.length === 0) {
                 endGame();
                 return; // Stop the loop
            }

            const emojiFieldRect = emojiField.getBoundingClientRect();

            // Use a reverse loop for safe removal during iteration
            for (let i = activeEmojis.length - 1; i >= 0; i--) {
                const emoji = activeEmojis[i];

                // Don't move if being dragged
                if (emoji.el.classList.contains('dragging')) continue;

                emoji.x += emoji.dx;
                emoji.y += emoji.dy;

                emoji.el.style.left = `${emoji.x}px`;
                emoji.el.style.top = `${emoji.y}px`;

                // Check for collision with the walls of the emojiField
                if (emoji.x < 0 || emoji.x > emojiFieldRect.width - emoji.el.offsetWidth ||
                    emoji.y < 0 || emoji.y > emojiFieldRect.height - emoji.el.offsetHeight) {
                    
                    // Remove emoji if it hits the edge
                    emoji.el.remove();
                    activeEmojis.splice(i, 1);
                    incrementEmojiCounter();
                }
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            scoreEl.textContent = score;
            emojiCounterEl.textContent = `${Math.min(emojiCount, MAX_EMOJIS)} / ${MAX_EMOJIS}`;
        }

        function incrementEmojiCounter() {
            emojiCount++;
            updateUI();
            // This is the main control to stop spawning new emojis
            if (emojiCount >= MAX_EMOJIS) {
                 clearInterval(emojiSpawner);
            }
        }
        
        function addScore(points, x, y) {
            score += points;
            updateUI();

            const popup = document.createElement('div');
            popup.textContent = (points > 0 ? `+` : '') + points;
            popup.className = `score-popup ${points > 0 ? 'text-green-500' : 'text-red-500'}`;
            // Position the popup relative to the play area for consistency
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            playArea.appendChild(popup);
            setTimeout(() => popup.remove(), 1500);
        }

        function endGame() {
            // Ensure all timers are stopped
            clearInterval(emojiSpawner);
            cancelAnimationFrame(animationFrameId);
            finalScoreEl.textContent = score;
            gameOverModal.style.display = 'flex';
        }

        // --- Drag and Drop Logic ---

        function startDrag(e) {
            e.preventDefault();
            const target = e.target;
            
            draggedEmoji = activeEmojis.find(emoji => emoji.el === target);
            if (!draggedEmoji) return;
            
            draggedEmoji.el.classList.add('dragging');

            const event = e.touches ? e.touches[0] : e;
            const rect = target.getBoundingClientRect();
            
            offsetX = event.clientX - rect.left;
            offsetY = event.clientY - rect.top;

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        }

        function onDrag(e) {
            if (!draggedEmoji) return;
            e.preventDefault();

            const event = e.touches ? e.touches[0] : e;
            const playAreaRect = playArea.getBoundingClientRect();

            // Calculate position relative to the playArea
            let newX = event.clientX - playAreaRect.left - offsetX;
            let newY = event.clientY - playAreaRect.top - offsetY;

            // Constrain movement to within the play area
            newX = Math.max(0, Math.min(newX, playAreaRect.width - draggedEmoji.el.offsetWidth));
            newY = Math.max(0, Math.min(newY, playAreaRect.height - draggedEmoji.el.offsetHeight));
            
            // The emoji element is a child of emojiField, but we set its position
            // relative to the playArea while dragging to allow it to go over the drop zones.
            draggedEmoji.el.style.left = `${newX}px`;
            draggedEmoji.el.style.top = `${newY}px`;
            
            checkDropZoneHover(event.clientX, event.clientY);
        }
        
        function checkDropZoneHover(clientX, clientY) {
            const keepRect = keepZoneEl.getBoundingClientRect();
            const sellRect = sellZoneEl.getBoundingClientRect();

            keepZoneEl.classList.toggle('over', clientX > keepRect.left && clientX < keepRect.right && clientY > keepRect.top && clientY < keepRect.bottom);
            sellZoneEl.classList.toggle('over', clientX > sellRect.left && clientX < sellRect.right && clientY > sellRect.top && clientY < sellRect.bottom);
        }


        function endDrag(e) {
            if (!draggedEmoji) return;
            
            const event = e.changedTouches ? e.changedTouches[0] : e;
            handleDrop(event.clientX, event.clientY);

            draggedEmoji.el.classList.remove('dragging');
            draggedEmoji = null;

            keepZoneEl.classList.remove('over');
            sellZoneEl.classList.remove('over');

            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchend', endDrag);
        }
        
        function handleDrop(clientX, clientY) {
            const keepRect = keepZoneEl.getBoundingClientRect();
            const sellRect = sellZoneEl.getBoundingClientRect();
            const emojiData = draggedEmoji.data;
            let points = 0;
            
            const droppedInKeep = clientX > keepRect.left && clientX < keepRect.right && clientY > keepRect.top && clientY < keepRect.bottom;
            const droppedInSell = clientX > sellRect.left && clientX < sellRect.right && clientY > sellRect.top && clientY < sellRect.bottom;

            if (droppedInKeep) {
                points = (emojiData.type === 'practical') ? emojiData.value : -Math.round(emojiData.value / 2);
            } else if (droppedInSell) {
                points = (emojiData.type === 'valuable') ? emojiData.value : -Math.round(emojiData.value / 2);
            } else {
                // *** BUG FIX ***
                // Not dropped in a valid zone. Restore its state based on its current visual position.
                // offsetLeft/Top are relative to the offsetParent (emojiField), which is what we need for the gameLoop physics.
                draggedEmoji.x = draggedEmoji.el.offsetLeft;
                draggedEmoji.y = draggedEmoji.el.offsetTop;
                return; 
            }

            // If dropped in a zone, process it
            addScore(points, draggedEmoji.el.offsetLeft, draggedEmoji.el.offsetTop);
            
            // Remove the emoji from the game
            draggedEmoji.el.remove();
            const index = activeEmojis.findIndex(emoji => emoji.el === draggedEmoji.el);
            if (index > -1) {
                activeEmojis.splice(index, 1);
            }
            incrementEmojiCounter();
        }

        restartButton.addEventListener('click', startGame);

        // --- Initial Start ---
        window.onload = startGame;
    </script>
</body>
</html>
