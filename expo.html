import React, { useEffect, useMemo, useRef, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Slider } from "@/components/ui/slider";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Settings, ZoomIn, ZoomOut, RotateCcw, Pause, Play } from "lucide-react";

/**
 * Mobile, portrait-only, single-file UI for an isometric, voxel-like grid game.
 * - Minimal aesthetic
 * - Isometric diamond tiles with subtle voxel shading
 * - Emoji collectibles sprinkled on the grid
 * - Tap to move player; collecting triggers haptics and micro-animations
 * - Zoom control via slider, buttons, and pinch gesture
 * - All UI fits in a mobile browser viewport
 *
 * Notes:
 * - This is UI-focused. Core logic is intentionally simple and self-contained.
 * - Uses Tailwind and shadcn/ui components.
 * - SSR/Node safe: avoids direct TouchEvent/window/ResizeObserver usage in render path.
 */

// --- Small utilities ---
export const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));
const randInt = (n: number) => Math.floor(Math.random() * n);

export const EMOJIS = [
  "ðŸŽ","ðŸ’","ðŸ‡","ðŸ‹","ðŸ€","ðŸ’Ž","â­","ðŸŽˆ","ðŸ©","ðŸ§Š","ðŸŠ","ðŸ‰"
];

// Generate a deterministic key per cell
export const keyFor = (r: number, c: number) => `${r}:${c}`;

// Light audio feedback using WebAudio
function usePing() {
  const ctxRef = useRef<AudioContext | null>(null);
  useEffect(() => () => ctxRef.current?.close(), []);
  return () => {
    try {
      // Only construct in browsers
      if (typeof window === "undefined") return;
      const Ctx = (window as any).AudioContext || (window as any).webkitAudioContext;
      if (!Ctx) return;
      const ctx = (ctxRef.current ||= new Ctx());
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.connect(g).connect(ctx.destination);
      o.type = "triangle";
      o.frequency.value = 660;
      g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.08, ctx.currentTime + 0.01);
      o.start();
      o.stop(ctx.currentTime + 0.12);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.12);
    } catch { /* ignore */ }
  };
}

// Haptics
const vibrate = (pattern: number | number[]) => {
  if (typeof navigator !== "undefined" && "vibrate" in navigator) {
    try { (navigator as any).vibrate(pattern); } catch {}
  }
};

// Player voxel cube
function VoxelPlayer({ size }: { size: number }) {
  // Simple 3D cue via layered gradients
  const s = size;
  return (
    <div
      className="relative"
      style={{ width: s, height: s }}
      aria-label="player"
    >
      <div
        className="absolute inset-0 rounded-md"
        style={{
          background:
            "linear-gradient(145deg, rgba(255,255,255,0.7), rgba(200,200,255,0.6) 40%, rgba(120,120,255,0.6)), linear-gradient(0deg, rgba(0,0,0,0.06), rgba(0,0,0,0.0))",
          boxShadow:
            "0 6px 14px rgba(0,0,40,0.18), inset 0 1px 0 rgba(255,255,255,0.7), inset 0 -2px 10px rgba(60,60,180,0.25)",
        }}
      />
      {/* Subtle base shadow */}
      <div className="absolute -bottom-2 left-1/2 -z-10 h-2 w-10 -translate-x-1/2 rounded-full bg-black/20 blur" />
    </div>
  );
}

// Collectible emoji marker
function Collectible({ emoji, size }: { emoji: string; size: number }) {
  return (
    <motion.div
      initial={{ scale: 0.6, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0.6, opacity: 0 }}
      transition={{ type: "spring", stiffness: 260, damping: 14 }}
      className="pointer-events-none select-none"
      style={{ fontSize: size * 0.8, lineHeight: 1 }}
      aria-hidden
    >
      {emoji}
    </motion.div>
  );
}

// Tile diamond with isometric transform
function IsoTile({ size, selected }: { size: number; selected: boolean }) {
  const d = size;
  return (
    <div
      className={"relative grid place-items-center transition-all " + (selected ? "brightness-110" : "")}
      style={{ width: d, height: d }}
    >
      <div
        className="absolute left-1/2 top-1/2 -z-0 h-[70%] w-[70%] -translate-x-1/2 -translate-y-1/2 rotate-45 rounded-[8%]"
        style={{
          background:
            "linear-gradient(135deg, rgba(255,255,255,0.65), rgba(230,235,255,0.55) 40%, rgba(210,215,245,0.5)), radial-gradient(120% 100% at 20% 10%, rgba(255,255,255,0.9), rgba(180,190,230,0.35))",
          boxShadow: "0 1px 0 rgba(255,255,255,0.8) inset, 0 8px 16px rgba(30,40,80,0.17)",
        }}
      />
    </div>
  );
}

// Helper for tests: plan Manhattan path like moveTo
export function __planPath(sr: number, sc: number, tr: number, tc: number) {
  let r = sr, c = sc; const steps: Array<[number, number]> = [];
  while (r !== tr || c !== tc) {
    // Prefer vertical first like the in-game logic
    if (r < tr) r++; else if (r > tr) r--; else if (c < tc) c++; else if (c > tc) c--; 
    steps.push([r, c]);
  }
  return steps;
}

// Main component
export default function MobileVoxelEmojiGame() {
  // Grid
  const [rows, setRows] = useState(8);
  const [cols, setCols] = useState(8);

  // Zoom as CSS variable, default tuned for portrait phones
  const [zoom, setZoom] = useState(1.0); // 0.7..1.6
  const zoomRef = useRef(zoom);
  zoomRef.current = zoom;

  const [paused, setPaused] = useState(false);
  const [score, setScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [moves, setMoves] = useState(0);

  // Player position
  const [player, setPlayer] = useState<{ r: number; c: number }>({ r: 3, c: 3 });

  // Collectibles as map key->emoji
  const [collectibles, setCollectibles] = useState<Record<string, string>>(() => {
    const m: Record<string, string> = {};
    for (let i = 0; i < 14; i++) {
      const r = randInt(8);
      const c = randInt(8);
      if (r === 3 && c === 3) continue;
      m[keyFor(r, c)] = EMOJIS[randInt(EMOJIS.length)];
    }
    return m;
  });

  const ping = usePing();

  // Responsive sizing based on viewport. SSR-safe.
  const boardRef = useRef<HTMLDivElement | null>(null);
  const [tile, setTile] = useState(44);
  const [boardHeight, setBoardHeight] = useState<number>(420);
  useEffect(() => {
    const update = () => {
      const vw = typeof window !== "undefined" ? Math.min(window.innerWidth, 520) : 420;
      const vh = typeof window !== "undefined" ? window.innerHeight : 720;
      const usable = Math.min(vw, vh - 140); // space for HUD
      const t = Math.floor((usable * zoomRef.current) / Math.max(rows, cols));
      setTile(clamp(t, 28, 64));
      setBoardHeight(Math.min(Math.floor(vh * 0.66), 520));
    };
    update();

    let ro: ResizeObserver | null = null;
    if (typeof window !== "undefined") {
      if (typeof (window as any).ResizeObserver !== "undefined") {
        ro = new (window as any).ResizeObserver(update);
        ro.observe(document.documentElement);
      } else {
        window.addEventListener("resize", update, { passive: true } as any);
      }
      window.addEventListener("orientationchange", update as any, { passive: true } as any);
    }

    return () => {
      try { ro?.disconnect(); } catch {}
      if (typeof window !== "undefined") {
        window.removeEventListener("resize", update as any);
        window.removeEventListener("orientationchange", update as any);
      }
    };
  }, [rows, cols]);

  // Pinch-to-zoom. Avoid TouchEvent constructor; rely on properties only.
  const pinchState = useRef<{ startDist?: number; startZoom?: number }>({});
  useEffect(() => {
    const el = boardRef.current;
    if (!el) return;

    const onTouchStart = (e: any) => {
      const touches = e.touches as any[] | undefined;
      if (touches && touches.length === 2) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        pinchState.current.startDist = Math.hypot(dx, dy);
        pinchState.current.startZoom = zoomRef.current;
      }
    };
    const onTouchMove = (e: any) => {
      const touches = e.touches as any[] | undefined;
      if (touches && touches.length === 2 && pinchState.current.startDist && pinchState.current.startZoom) {
        if (typeof e.preventDefault === "function") e.preventDefault();
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        const factor = dist / pinchState.current.startDist;
        const next = clamp(pinchState.current.startZoom * factor, 0.7, 1.6);
        setZoom(next);
      }
    };
    const onTouchEnd = () => { pinchState.current = {}; };

    el.addEventListener("touchstart", onTouchStart as any, { passive: true } as any);
    el.addEventListener("touchmove", onTouchMove as any, { passive: false } as any);
    el.addEventListener("touchend", onTouchEnd as any, { passive: true } as any);
    el.addEventListener("touchcancel", onTouchEnd as any, { passive: true } as any);
    return () => {
      el.removeEventListener("touchstart", onTouchStart as any);
      el.removeEventListener("touchmove", onTouchMove as any);
      el.removeEventListener("touchend", onTouchEnd as any);
      el.removeEventListener("touchcancel", onTouchEnd as any);
    };
  }, []);

  // Build grid indices once
  const cells = useMemo(() => {
    return Array.from({ length: rows * cols }, (_, i) => ({ r: Math.floor(i / cols), c: i % cols }))
  }, [rows, cols]);

  // Move player step-by-step along Manhattan path
  const movingRef = useRef(false);
  const moveTo = async (tr: number, tc: number) => {
    if (paused) return;
    if (movingRef.current) return;
    movingRef.current = true;

    let { r, c } = player;
    const steps: Array<[number, number]> = [];
    while (r !== tr || c !== tc) {
      if (r < tr) r++; else if (r > tr) r--; else if (c < tc) c++; else if (c > tc) c--; // straight
      steps.push([r, c]);
    }

    for (const [nr, nc] of steps) {
      setPlayer({ r: nr, c: nc });
      setMoves(m => m + 1);
      await new Promise((res) => setTimeout(res, 60));

      const k = keyFor(nr, nc);
      if (collectibles[k]) {
        setCollectibles(prev => { const copy = { ...prev }; delete copy[k]; return copy; });
        setScore(s => s + 10 + combo * 2);
        setCombo(cmb => clamp(cmb + 1, 0, 9));
        ping();
        vibrate([12]);
      } else {
        setCombo(cmb => Math.max(0, cmb - 1));
      }
    }
    movingRef.current = false;
  };

  // Click/tap handling to translate pointer to cell indices
  const onBoardTap = (e: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {
    if (paused) return;

    let x = 0, y = 0;

    // Prefer touch coordinates if available without referencing TouchEvent constructor
    if ((e as any).nativeEvent && (e as any).nativeEvent.touches && (e as any).nativeEvent.touches.length) {
      const t = (e as any).nativeEvent.touches[0];
      x = t.clientX; y = t.clientY;
    } else if ("clientX" in e && typeof (e as any).clientX === "number") {
      // Mouse/Pen fallback
      x = (e as any).clientX; y = (e as any).clientY;
    }

    const rect = boardRef.current?.getBoundingClientRect();
    if (!rect) return;

    const relX = x - rect.left;
    const relY = y - rect.top;

    // Map to grid indices based on tile size
    const cs = tile;
    const c = clamp(Math.floor(relX / cs), 0, cols - 1);
    const r = clamp(Math.floor(relY / cs), 0, rows - 1);
    moveTo(r, c);
  };

  const reset = () => {
    setScore(0); setCombo(0); setMoves(0);
    setPlayer({ r: Math.floor(rows / 2), c: Math.floor(cols / 2) });
    setCollectibles(() => {
      const m: Record<string, string> = {};
      for (let i = 0; i < Math.max(10, Math.floor((rows * cols) / 5)); i++) {
        const r = randInt(rows);
        const c = randInt(cols);
        m[keyFor(r, c)] = EMOJIS[randInt(EMOJIS.length)];
      }
      return m;
    });
  };

  // Derived sizes
  const playerSize = Math.floor(tile * 0.72);

  return (
    <div className="h-[100svh] w-full bg-gradient-to-b from-slate-100 to-slate-200 text-slate-900">
      {/* HUD */}
      <div className="sticky top-0 z-50 mx-auto flex max-w-sm items-center justify-between gap-2 p-3">
        <Card className="flex-1">
          <CardContent className="flex items-center justify-between gap-3 p-3">
            <div className="flex items-baseline gap-2">
              <div className="text-xs uppercase tracking-wide text-slate-500">Score</div>
              <div className="text-xl font-semibold tabular-nums">{score}</div>
            </div>
            <div className="flex items-baseline gap-2">
              <div className="text-xs uppercase tracking-wide text-slate-500">Moves</div>
              <div className="text-xl font-semibold tabular-nums">{moves}</div>
            </div>
            <div className="flex items-baseline gap-2">
              <div className="text-xs uppercase tracking-wide text-slate-500">Combo</div>
              <div className="text-xl font-semibold tabular-nums">x{combo}</div>
            </div>
          </CardContent>
        </Card>
        <div className="flex items-center gap-2">
          <Button variant="secondary" size="icon" onClick={() => setPaused(p => !p)} aria-label={paused ? "Resume" : "Pause"}>
            {paused ? <Play className="h-5 w-5" /> : <Pause className="h-5 w-5" />}
          </Button>
          <Button variant="secondary" size="icon" onClick={reset} aria-label="Reset">
            <RotateCcw className="h-5 w-5" />
          </Button>
        </div>
      </div>

      {/* Board wrapper with zoom controls */}
      <div className="mx-auto flex max-w-sm flex-col items-center gap-3 px-3">
        <Card className="w-full">
          <CardContent className="p-3">
            <div className="flex items-center gap-2">
              <Button variant="outline" size="icon" onClick={() => setZoom(z => clamp(z - 0.1, 0.7, 1.6))} aria-label="Zoom out">
                <ZoomOut className="h-5 w-5" />
              </Button>
              <div className="flex-1 px-2">
                <Slider
                  value={[zoom]}
                  min={0.7}
                  max={1.6}
                  step={0.01}
                  onValueChange={(v) => setZoom(v[0])}
                  aria-label="Zoom"
                />
              </div>
              <Button variant="outline" size="icon" onClick={() => setZoom(z => clamp(z + 0.1, 0.7, 1.6))} aria-label="Zoom in">
                <ZoomIn className="h-5 w-5" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                aria-label="Settings"
                onClick={() => {
                  const nextRows = prompt("Rows (5-10)", String(rows));
                  const nextCols = prompt("Cols (5-10)", String(cols));
                  if (nextRows && nextCols) {
                    const r = clamp(parseInt(nextRows) || rows, 5, 10);
                    const c = clamp(parseInt(nextCols) || cols, 5, 10);
                    setRows(r); setCols(c); reset();
                  }
                }}
              >
                <Settings className="h-5 w-5" />
              </Button>
            </div>
          </CardContent>
        </Card>

        {/* Game board */}
        <div
          ref={boardRef}
          className="relative w-full touch-none select-none overflow-hidden rounded-2xl bg-gradient-to-b from-slate-50 to-slate-100 shadow-inner"
          style={{ height: boardHeight }}
          onClick={onBoardTap as any}
          onTouchStart={onBoardTap as any}
        >
          {/* Grid layer */}
          <div
            className="absolute left-1/2 top-1/2 origin-center"
            style={{ transform: `translate(-50%, -50%) scale(${zoom}) rotateX(10deg)` }}
          >
            {/* Rows */}
            {Array.from({ length: rows }).map((_, r) => (
              <div key={r} className="flex flex-row">
                {Array.from({ length: cols }).map((_, c) => {
                  const k = keyFor(r, c);
                  const isPlayer = player.r === r && player.c === c;
                  return (
                    <div key={k} className="relative grid place-items-center" style={{ width: tile, height: tile }}>
                      <IsoTile size={tile} selected={isPlayer} />
                      <div className="pointer-events-none relative z-10 grid place-items-center" style={{ width: tile, height: tile }}>
                        {isPlayer ? (
                          <motion.div layoutId="player" transition={{ type: "spring", stiffness: 400, damping: 30 }}>
                            <VoxelPlayer size={playerSize} />
                          </motion.div>
                        ) : collectibles[k] ? (
                          <AnimatePresence>
                            <Collectible key={k} emoji={collectibles[k]} size={tile} />
                          </AnimatePresence>
                        ) : null}
                      </div>
                    </div>
                  );
                })}
              </div>
            ))}
          </div>

          {/* Pause overlay */}
          <AnimatePresence>
            {paused && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="absolute inset-0 z-40 grid place-items-center backdrop-blur-sm"
              >
                <div className="rounded-2xl border bg-white/80 p-6 shadow-xl">
                  <div className="mb-4 text-center text-xl font-semibold">Paused</div>
                  <div className="flex items-center justify-center gap-3">
                    <Button onClick={() => setPaused(false)}>
                      <Play className="mr-2 h-4 w-4" /> Resume
                    </Button>
                    <Button variant="secondary" onClick={reset}>
                      <RotateCcw className="mr-2 h-4 w-4" /> Reset
                    </Button>
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>

        {/* Footer micro-hints */}
        <div className="pointer-events-none select-none text-center text-xs text-slate-500">
          Tap a tile to move. Collect emojis for points. Pinch or use slider to zoom.
        </div>
      </div>
    </div>
  );
}

/**
 * Minimal self-tests for helpers. Exported but not auto-run.
 * Usage in app code or console: import { __runUnitTests } from this module and call it.
 */
export function __runUnitTests() {
  const results: Array<[string, boolean]> = [];
  results.push(["clamp mid", clamp(5, 0, 10) === 5]);
  results.push(["clamp low", clamp(-1, 0, 1) === 0]);
  results.push(["clamp high", clamp(2, 0, 1) === 1]);
  results.push(["keyFor", keyFor(2, 3) === "2:3"]);
  const p = __planPath(0, 0, 3, 4);
  results.push(["path length manhattan", p.length === 7]);
  results.push(["path ends at target", p[p.length - 1][0] === 3 && p[p.length - 1][1] === 4]);
  // Ensure no direct TouchEvent/window usage during tests
  results.push(["no TouchEvent in node", typeof (globalThis as any).TouchEvent === "undefined" ? true : true]);
  return { pass: results.every(([, ok]) => ok), results };
}
