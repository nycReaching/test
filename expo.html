<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 
      This meta tag is CRITICAL for mobile. 
      - width=device-width sets the width to the device's screen.
      - initial-scale=1.0 prevents default zoom.
      - user-scalable=no stops the user from pinching to zoom, which is good for a game.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Isometric Game UI</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Basic Setup --- */
        html, body {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', 'Roboto', sans-serif;
            background-color: #000000;
            color: #ffffff;
            /* Prevents scrolling, pull-to-refresh, etc. */
            overflow: hidden; 
        }

        body {
            /* This is the key for full mobile compatibility.
              100dvh = 100% of the *dynamic* viewport height.
              It resizes when mobile URL bars and nav bars appear/disappear.
            */
            height: 100dvh;
            
            /* Main layout: Game area on top, controls on bottom */
            display: flex;
            flex-direction: column;
        }

        /* --- Game Area --- */
        #game-area {
            /* This makes the game area fill all available space */
            flex: 1;
            display: grid;
            place-items: center;
            overflow: hidden;
        }

        #pan-zoom-wrapper {
            /* This new wrapper handles panning and zooming */
            transform-origin: center;
            /* This makes panning/zooming instant and responsive */
            transition: none; 
        }

        #iso-wrapper {
            position: relative;
            /* This is the isometric transform: tilt forward, then rotate */
            transform: rotateX(60deg) rotateZ(-45deg);
            transform-style: preserve-3d;
            /* Adds 3D perspective to this element */
            perspective: 800px;
        }

        #grid {
            display: grid;
            /* Grid size will be set by JS */
            transform-style: preserve-3d;
        }

        .grid-cell {
            box-sizing: border-box; 
            /* Subtle dark border for separation */
            border: 1px solid #111; 
            /* Creates a shadow effect to make it look chunky */
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            /* Add a subtle feedback on tap */
            transition: background-color 0.1s, transform 0.3s ease;
        }

        /* Terrain Styles (Defined in JS for dynamic application) */
        .water { background-color: #004d40; }
        .grass { background-color: #388e3c; }
        .rock  { background-color: #424242; }

        .grid-cell:active {
            filter: brightness(1.5);
        }

        .emoji-item {
            /* Style for the emoji items */
            font-size: 30px; 
            display: block; 
            text-align: center; 
            line-height: 60px; /* CELL_SIZE / 2 */
            transform: translateZ(10px); /* Lifts emoji higher than player */
            user-select: none;
        }

        #player {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #00ff00;
            box-shadow: 0 0 10px #00ff00, 0 0 5px #ffffff;
            
            /* Lifts the player slightly above the grid lines */
            transform: translateZ(10px);
            
            /* Smooth movement - Slower and smoother */
            transition: transform 0.5s ease-in-out; 
        }

    </style>
</head>
<body>

    <div id="game-area">
        <div id="pan-zoom-wrapper"> 
            <div id="iso-wrapper">
                <div id="grid"></div>
                <div id="player"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Game State & Constants ---
            const GRID_SIZE = 15; 
            const CELL_SIZE = 60; 
            
            // Player position (1-indexed, so 1 to GRID_SIZE)
            let playerX = Math.floor(GRID_SIZE / 2); 
            let playerY = Math.floor(GRID_SIZE / 2);

            const TERRAIN_TYPES = {
                WATER: { id: 0, class: 'water', height: 0 },
                GRASS: { id: 1, class: 'grass', height: 10 },
                ROCK: { id: 2, class: 'rock', height: 20 }
            };

            const EMOJIS = ['ðŸš€', 'ðŸŒ²', 'â­', 'ðŸ’Ž', 'ðŸ”‘', 'ðŸ’°'];
            const EMOJI_COUNT = 5;

            const terrainMap = []; // Stores TERRAIN_TYPES objects

            // --- Pan & Zoom State ---
            let currentScale = 1.0;
            let currentPanX = 0;
            let currentPanY = 0;
            let isPanning = false;
            let lastPanX = 0;
            let lastPanY = 0;
            let isPinching = false;
            let lastPinchDist = 0;

            // --- Element References ---
            const grid = document.getElementById('grid');
            const player = document.getElementById('player');
            const gameArea = document.getElementById('game-area');

            // --- Utility Functions ---

            /**
             * Returns the current Z-offset (height) for a given 1-indexed (x, y) coordinate.
             * Returns 0 if outside the map bounds.
             */
            function getTerrainHeight(x, y) {
                // Adjust to 0-indexing
                const row = y - 1;
                const col = x - 1;
                
                if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                    const terrainType = terrainMap[row] ? terrainMap[row][col] : null;
                    return terrainType ? terrainType.height : 0;
                }
                return 0; 
            }

            // --- Initialization ---
            function initGame() {
                // 1. Setup Grid CSS
                grid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
                grid.style.gridTemplateRows = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
                player.style.width = `${CELL_SIZE}px`;
                player.style.height = `${CELL_SIZE}px`;

                // 2. Determine random emoji positions
                const emojiPositions = new Set();
                while (emojiPositions.size < EMOJI_COUNT) {
                    const x = Math.floor(Math.random() * GRID_SIZE) + 1;
                    const y = Math.floor(Math.random() * GRID_SIZE) + 1;
                    if (x !== playerX || y !== playerY) {
                        emojiPositions.add(`${x},${y}`);
                    }
                }
                
                // 3. Generate Terrain Map (FIXED: Initialization of inner array added)
                for (let i = 0; i < GRID_SIZE; i++) {
                    terrainMap[i] = []; // CRITICAL FIX: Initialize the row array
                    for (let j = 0; j < GRID_SIZE; j++) {
                        let type = TERRAIN_TYPES.WATER;
                        
                        // Simple noise generation for terrain
                        const noise = Math.random();
                        if (noise > 0.7) {
                            type = TERRAIN_TYPES.ROCK;
                        } else if (noise > 0.3) {
                            type = TERRAIN_TYPES.GRASS;
                        }
                        
                        // Assign type to map (i = row index, j = col index)
                        terrainMap[i][j] = type;
                    }
                }

                // 4. Generate Grid Cells and Emojis
                grid.innerHTML = ''; 
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const cell = document.createElement('div');
                    
                    // Get coordinates (1-indexed) and corresponding terrain data
                    const x = (i % GRID_SIZE) + 1;
                    const y = Math.floor(i / GRID_SIZE) + 1;
                    const type = terrainMap[y - 1][x - 1]; // Use 0-indexing to lookup map data

                    cell.classList.add('grid-cell', type.class);
                    cell.style.width = `${CELL_SIZE}px`;
                    cell.style.height = `${CELL_SIZE}px`;
                    
                    const height = type.height;
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.dataset.height = height;
                    
                    // Apply Z translation to lift the cell based on terrain height
                    cell.style.transform = `translateZ(-${height}px)`;


                    // Add emoji if position matches
                    if (emojiPositions.has(`${x},${y}`)) {
                        const randomIndex = Math.floor(Math.random() * EMOJIS.length);
                        // Center the emoji
                        cell.innerHTML = `
                            <span class="emoji-item" style="line-height: ${CELL_SIZE}px; font-size: ${CELL_SIZE * 0.5}px;">
                                ${EMOJIS[randomIndex]}
                            </span>`;
                    }

                    // Add tap listener
                    cell.addEventListener('touchstart', (e) => {
                        e.stopPropagation(); 
                        
                        if (e.touches.length > 1) return;
                        
                        const targetX = parseInt(e.currentTarget.dataset.x, 10);
                        const targetY = parseInt(e.currentTarget.dataset.y, 10);
                        movePlayerTo(targetX, targetY);
                    }, { passive: true });

                    grid.appendChild(cell);
                }

                // 5. Set initial player position
                updatePlayerPosition();
                
                // 6. Attach Pan/Zoom Listeners to game area
                gameArea.addEventListener('touchstart', onTouchStart);
                gameArea.addEventListener('touchmove', onTouchMove, { passive: false });
                gameArea.addEventListener('touchend', onTouchEnd);
                gameArea.addEventListener('touchcancel', onTouchEnd);
            }

            // --- Game Logic ---
            
            /**
             * Updates the player's visual position on the grid.
             */
            function updatePlayerPosition() {
                // Get the height of the current block
                const currentZ = getTerrainHeight(playerX, playerY);

                // Calculate the pixel position. (playerX-1) because position is 1-indexed.
                const xPos = (playerX - 1) * CELL_SIZE;
                const yPos = (playerY - 1) * CELL_SIZE;

                // Use CSS transform to move the player.
                // We set the Z translation *down* by the terrain height, 
                // so the player rests on the top surface. (Lighter cube on top of block)
                player.style.transform = `translate(${xPos}px, ${yPos}px) translateZ(-${currentZ}px)`;
            }

            /**
             * Moves the player to a specific (x, y) coordinate.
             */
            function movePlayerTo(x, y) {
                if (x >= 1 && x <= GRID_SIZE && y >= 1 && y <= GRID_SIZE) {
                    // Update state
                    playerX = x;
                    playerY = y;
                    
                    // Update the visual position
                    updatePlayerPosition();
                }
            }
            
            // --- Pan & Zoom Functions ---

            /**
             * Applies current pan and scale to the pan-zoom-wrapper.
             */
            function updateWrapperTransform() {
                const wrapper = document.getElementById('pan-zoom-wrapper'); 
                // Apply translate and scale.
                wrapper.style.transform = 
                    `translate(${currentPanX}px, ${currentPanY}px) ` +
                    `scale(${currentScale})`;
            }

            /**
             * Calculates distance between two touch points.
             */
            function getDist(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function onTouchStart(e) {
                if (e.touches.length === 1) {
                    // Start Panning
                    isPanning = true;
                    lastPanX = e.touches[0].clientX;
                    lastPanY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    // Start Pinching
                    isPinching = true;
                    isPanning = false; 
                    lastPinchDist = getDist(e.touches[0], e.touches[1]);
                }
            }

            function onTouchMove(e) {
                // Prevent default browser scroll/zoom
                e.preventDefault(); 

                if (isPinching && e.touches.length === 2) {
                    // Handle Pinch
                    const newDist = getDist(e.touches[0], e.touches[1]);
                    const deltaDist = newDist - lastPinchDist;
                    
                    // Adjust scale (zooming in/out)
                    currentScale += deltaDist * 0.005; 
                    
                    // Add constraints to scale
                    if (currentScale < 0.5) currentScale = 0.5;
                    if (currentScale > 3.0) currentScale = 3.0;

                    lastPinchDist = newDist;
                    updateWrapperTransform();

                } else if (isPanning && e.touches.length === 1) {
                    // Handle Pan
                    const newX = e.touches[0].clientX;
                    const newY = e.touches[0].clientY;

                    const deltaX = newX - lastPanX;
                    const deltaY = newY - lastPanY;

                    currentPanX += deltaX;
                    currentPanY += deltaY;

                    lastPanX = newX;
                    lastPanY = newY;
                    updateWrapperTransform();
                }
            }

            function onTouchEnd(e) {
                if (e.touches.length < 2) {
                    isPinching = false;
                }
                if (e.touches.length < 1) {
                    isPanning = false;
                }
            }
            
            // Start the game
            initGame();
        });
    </script>
</body>
</html>
